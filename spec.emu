<!DOCTYPE html>
<html lang="en-GB-oxendict">
<meta charset="utf-8">
<link rel="icon" href="img/favicon.ico">
<style>
  #metadata-block {
    margin: 4em 0;
    padding: 10px;
    border: 1px solid #ee8421;
  }
  #metadata-block h1 {
    font-size: 1.5em;
    margin-top: 0;
  }
  #metadata-block > ul {
    list-style-type: none;
    margin: 0; padding: 0;
  }

  #ecma-logo {
    width: 500px;
  }

  /* TODO: Get proper Ecmarkup support for examples */
  emu-note[example] {
    --note-type: example;
    --note-label: "Example";
    --note-text-color: #574b0f;
    --note-border-color: #e0cb52;
    --note-background-color: #fcfaee;
  }
  emu-note[issue] {
    --note-type: issue;
    --note-label: "Issue";
    --note-border-color: #e05252;
    --note-background-color: #fbe9e9;
  }

  emu-note[issue], emu-note[example] {
    color: black;
    counter-increment: var(--note-type);
    border-left-color: var(--note-border-color);
    background-color: var(--note-background-color);
    padding: 0.5em;

    &::before {
      content: var(--note-label) "\00A0" counter(var(--note-type));
      color: var(--note-text-color, black);
      text-transform: uppercase;
    }

    & .note {
      display: none;
    }
  }

  emu-clause[example][normative-optional] .attributes-tag emu-xref {
    display: none;
  }
  emu-clause[example][normative-optional] .attributes-tag::before {
    content: "Example";
  }

  dfn code {
    font-style: normal;
  }

  emu-annex#sec-external-definitions dd dfn {
    font-style: normal;
  }
</style>
<pre class="metadata">
  title: Source map format specification
  shortname: ECMA-426
  status: draft
  location: https://tc39.es/ecma426/
</pre>
<p><img src="img/ecma-logo.svg" id="ecma-logo" alt="Ecma International logo"></p>
<div id="metadata-block">
  <h1>About this Specification</h1>
  <p>The document at <a href="https://tc39.es/ecma426/">https://tc39.es/ecma426/</a> is the most accurate and up-to-date source map specification. It contains the content of the most recently published snapshot plus any modifications that will be included in the next snapshot.</p>
  <h1>Contributing to this Specification</h1>
  <p>This specification is developed on GitHub. There are a number of ways to contribute to the development of this specification:</p>
  <ul>
    <li>GitHub Repository: <a href="https://github.com/tc39/ecma426">https://github.com/tc39/ecma426</a></li>
    <li>Issues: <a href="https://github.com/tc39/ecma426/issues">All Issues</a>, <a href="https://github.com/tc39/ecma426/issues/new">File a New Issue</a></li>
    <li>Pull Requests: <a href="https://github.com/tc39/ecma426/pulls">All Pull Requests</a>, <a href="https://github.com/tc39/ecma426/pulls/new">Create a New Pull Request</a></li>
    <li>Test Suite: <a href="https://github.com/tc39/source-map-tests/">tc39/source-map-tests</a></li>
    <li>
      Editors:
      <ul>
        <li><a href="https://github.com/takikawa">Asumu Takikawa</a> (Igalia)</li>
      </ul>
    </li>
  </ul>
  <p>Refer to the <emu-xref href="#sec-colophon">colophon</emu-xref> for more information on how this document is created.</p>
</div>

<emu-intro id="sec-intro">
  <h1>Introduction</h1>
  <p>This Ecma Standard defines the Source map format, used for mapping transpiled source code back to the original sources.</p>
  <p>The source map format has the following goals:</p>
  <ul>
    <li>Support source-level debugging allowing bidirectional mapping</li>
    <li>Support server-side stack trace deobfuscation</li>
  </ul>
  <p>The <emu-not-ref>original source</emu-not-ref> map format (v1) was created by Joseph Schorr for use by Closure Inspector to enable source-level debugging of optimized JavaScript code (although the format itself is language agnostic). However, as the size of the projects using source maps expanded, the verbosity of the format started to become a problem. The v2 format (Source Map Revision 2 Proposal) was created by trading some simplicity and flexibility to reduce the overall size of the source map. Even with the changes made with the v2 version of the format, the source map file size was limiting its usefulness. The v3 format is based on suggestions made by Pavel Podivilov (Google).</p>
  <p>The source map format does not have version numbers anymore, and it is instead hard-coded to always be "3".</p>
  <p>In 2023-2024, the source map format was developed into a more precise Ecma standard, with significant contributions from many people. Further iteration on the source map format is expected to come from TC39-TG4.</p>
  <p>
    Asumu Takikawa, Nicol√≤ Ribaudo, Jon Kuperman<br>
    ECMA-426, 1<sup>st</sup> edition, Project Editors
  </p>
</emu-intro>

<emu-clause id="sec-scope">
  <h1>Scope</h1>
  <p>This Standard defines the source map format, used by different types of developer tools to improve the debugging experience of code compiled to JavaScript, WebAssembly, and CSS.</p>
</emu-clause>

<emu-clause id="sec-conformance">
  <h1>Conformance</h1>
  <p>A conforming source map document is a JSON document that conforms to the structure detailed in this specification.</p>
  <p>A conforming source map generator should generate documents which are conforming source map documents, and can be decoded by the algorithms in this specification without reporting any errors (even those which are specified as optional).</p>
  <p>A conforming source map consumer should implement the algorithms specified in this specification for retrieving (where applicable) and decoding source map documents. A conforming consumer is permitted to ignore errors or report them without terminating where the specification indicates that an algorithm may optionally report an error.</p>
</emu-clause>

<emu-clause id="sec-references">
  <h1>References</h1>
  <p>The following documents are referred to in the text in such a way that some or all of their content constitutes requirements of this document. For dated references, only the edition cited applies. For undated references, the latest edition of the referenced document (including any amendments) applies.</p>

  <!-- All documents listed here must also be listed in the "Biography" annex. -->

  <emu-clause id="sec-references-normative">
    <h1>Normative References</h1>
    <p>
      ECMA-262, <i>ECMAScript¬Æ Language Specification</i>.<br>
      <a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>
    </p>
    <p>
      ECMA-404, <i>The JSON Data Interchange Format</i>.<br>
      <a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>
    </p>
  </emu-clause>

  <emu-clause id="sec-references-informative">
    <h1>Informative References</h1>

    <!-- NOTE: These references should actually be normative, but Ecma is allergic to normatively referencing web specs. As a rule of thumb, Ecma/IEEE/Unicode specs can go in the "normative" section, while the rest should go here. -->

    <p>
      IETF RFC 4648, <i>The Base16, Base32, and Base64 Data Encodings</i>.<br>
      <a href="https://datatracker.ietf.org/doc/html/rfc4648">https://datatracker.ietf.org/doc/html/rfc4648</a>
    </p>
    <p>
      <i>WebAssembly Core Specification</i>.<br>
      <a href="https://www.w3.org/TR/wasm-core-2/">https://www.w3.org/TR/wasm-core-2/</a>
    </p>
    <p>
      WHATWG <i>Encoding</i>.<br>
      <a href="https://encoding.spec.whatwg.org/">https://encoding.spec.whatwg.org/</a>
    </p>
    <p>
      WHATWG <emu-not-ref><i>Fetch</i></emu-not-ref>.<br>
      <a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>
    </p>
    <p>
      WHATWG <i>Infra</i>.<br>
      <a href="https://infra.spec.whatwg.org/">https://infra.spec.whatwg.org/</a>
    </p>
    <p>
      WHATWG <emu-not-ref><i>URL</i></emu-not-ref>.<br>
      <a href="https://url.spec.whatwg.org/">https://url.spec.whatwg.org/</a>
    </p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-notational-conventions">
  <h1>Notational Conventions</h1>
  <p>This specification follows the same notational conventions as defined by <a href="https://tc39.es/ecma262/#sec-notational-conventions">ECMA-262 (Notational conventions)</a>, with the extensions defined in this section.</p>

  <emu-clause id="sec-algorithm-conventions">
    <h1>Algorithm Conventions</h1>

    <emu-clause id="sec-implicit-completions">
      <h1>Implicit Completions</h1>

      <p>All abstract operations declared in this specification are implicitly assumed to either return a normal completion containing the algorithm's declared return type, or a throw completion. For example, an abstract operation declared as</p>

      <blockquote>

        <emu-clause id="example-get-the-answer" type="abstract operation" example>
          <h1>
            GetTheAnswer (
              _input_: an integer,
            ): an integer
          </h1>
          <dl class="header"></dl>
        </emu-clause>
      </blockquote>
      <p>is equivalent to:</p>
      <blockquote>

        <emu-clause id="example-get-the-answer-2" type="abstract operation" example>
          <h1>
            GetTheAnswer2 (
              _input_: an integer,
            ): either a normal completion containing an integer or a throw completion
          </h1>
          <dl class="header"></dl>
        </emu-clause>
      </blockquote>

      <p>All calls to abstract operations that return completion records are implicitly assumed to be wrapped by a ReturnIfAbrupt macro, unless they are explicitly wrapped by an explicit Completion call. For example:</p>
      <emu-alg example>
        1. Let _result_ be GetTheAnswer(_value_).
        1. Let _second_ be Completion(GetTheAnswer(_value_)).
      </emu-alg>
      <p>is equivalent to:</p>
      <emu-alg example>
        1. Let _result_ be ReturnIfAbrupt(GetTheAnswer(_value_)).
        1. Let _second_ be Completion(GetTheAnswer(_value_)).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-optional-errors">
      <h1>Optional Errors</h1>

      <p>Whenever an algorithm is to <dfn>optionally report an error</dfn>, an implementation may choose one of the following behaviours:</p>
      <ul>
        <li>Continue executing the rest of the algorithm.</li>
        <li>Report an error to the user (for example, in the browser console), and continue executing the rest of the algorithm.</li>
        <li>Return a ThrowCompletion.</li>
      </ul>

      <p>An implementation can choose different behaviours for different optional errors.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-grammar-notation">
    <h1>Grammar Notation</h1>
    <p>This specification follows the same grammar notation convention as defined by <a href="https://tc39.es/ecma262/#sec-grammar-notation">ECMA-262 (Grammar Notation)</a>, with the following caveats:</p>
    <ul>
      <li>The terminal symbols of grammars defined in this specification are individual code points. This is similar to ECMA-262's <a href="https://tc39.es/ecma262/#sec-lexical-and-regexp-grammars">lexical grammar</a>, rather than to ECMA-262's <a href="https://tc39.es/ecma262/#sec-syntactic-grammar">syntactic grammar</a>.</li>
      <li>This specification does not use <a href="https://tc39.es/ecma262/#sec-grammatical-parameters">grammatical parameters</a> or <a href="https://tc39.es/ecma262/#sec-lookahead-restrictions">lookahead restrictions</a>, to reduce the grammar definitions complexity.</li>
    </ul>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-terms-and-definitions">
  <h1>Terms and Definitions</h1>
  <p>For the purposes of this document, the following terms and definitions apply.</p>

  <dl>
    <dt><dfn id="sec-terms-and-definitions-generated-code">generated code</dfn></dt>
    <dd>
      <p>code which is generated by the compiler or transpiler.</p>
    </dd>

    <dt><dfn id="sec-terms-and-definitions-original-source">original source</dfn></dt>
    <dd>
      <p>source code which has not been passed through a compiler or transpiler.</p>
    </dd>

    <dt><dfn id="sec-terms-and-definitions-source-mapping-url">source map URL</dfn></dt>
    <dd>
      <p>URL referencing the location of a source map from the generated code.</p>
    </dd>

    <dt><dfn id="sec-terms-and-definitions-colun">column</dfn></dt>
    <dd>
      <p>zero-based indexed offset within a line of the generated code, computed as UTF-16 code units for JavaScript and CSS source maps, and as byte indices in the binary content (represented as a single line) for WebAssembly source maps.</p>
      <emu-note>That means that "A" (`LATIN CAPITAL LETTER A`) measures as 1 code unit, and "üî•" (`FIRE`) measures as 2 code units. Source maps for other content types may diverge from this.</emu-note>
    </dd>

    <ins class="block">
      <dt><dfn id="sec-terms-and-definitions-original-scope" variants="original scopes">original scope</dfn></dt>
      <dd>
        <p>a lexical scope in an original source file.</p>
      </dd>

      <dt><dfn id="sec-terms-and-definitions-generated-range" variants="generated ranges">generated range</dfn></dt>
      <dd>
        <p>a code range in generated code. The term <em>range</em> is chosen deliberately: A range does not necessarily correspond to a lexical JavaScript/WASM scope, e.g. when function bodies were inlined by a compiler.</p>
      </dd>
    </ins>
  </dl>
</emu-clause>

<emu-clause id="sec-base64-vlq">
  <h1>base64 VLQ</h1>
  <p>A <dfn id="sec-base64-vlq">base64 VLQ</dfn> is a <emu-xref href="#sec-references-informative">base64</emu-xref>-encoded variable-length quantity, where the most significant bit (the 6th bit) is used as the continuation bit, and the "digits" are encoded into the string least significant first, and where the least significant bit of the first digit is used as the sign bit.</p>
  <emu-note>The values that can be represented by the base64 VLQ encoding are limited to 32-bit quantities until some use case for larger values is presented. This means that values exceeding 32-bits are invalid and implementations may reject them. The sign bit is counted towards the limit, but the continuation bits are not.</emu-note>
  <emu-note example>
    The string `"iB"` represents a base64 VLQ with two digits. The first digit `"i"` encodes the bit pattern `0x100010`, which has a continuation bit of `1` (the VLQ continues), a sign bit of `0` (non-negative), and the value bits `0x0001`. The second digit `B` encodes the bit pattern `0x000001`, which has a continuation bit of `0`, no sign bit, and value bits `0x00001`. The decoding of this VLQ string is the number 17.
  </emu-note>
  <emu-note example>
    The string `"V"` represents a base64 VLQ with one digit. The digit `"V"` encodes the bit pattern `0x010101`, which has a continuation bit of `0` (no continuation), a sign bit of `1` (negative), and the value bits `0x1010`. The decoding of this VLQ string is the number -10.
  </emu-note>
  <p>A base64 VLQ adheres to the following lexical grammar:</p>

  <emu-grammar type="definition">
    Vlq ::
      VlqDigitList

    VlqDigitList ::
      TerminalDigit
      ContinuationDigit VlqDigitList

    TerminalDigit ::
      `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R`
      `S` `T` `U` `V` `W` `X` `Y` `Z` `a` `b` `c` `d` `e` `f`

    ContinuationDigit ::
      `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x`
      `y` `z` `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `+` `/`
  </emu-grammar>

  <emu-clause id="sec-VLQSignedValue" type="sdo">
    <h1>VLQSignedValue ( ): an integer</h1>
    <dl class="header"></dl>
    <emu-grammar>
      Vlq :: VlqDigitList
    </emu-grammar>
    <emu-alg>
      1. Let _unsigned_ be the VLQUnsignedValue of |VlqDigitList|.
      1. If _unsigned_ modulo 2 = 1, let _sign_ be -1.
      1. Else, let _sign_ be 1.
      1. Let _value_ be floor(_unsigned_ / 2).
      1. If _value_ is 0 and _sign_ is -1, return -2<sup>31</sup>.
      1. [id="step-VLQSignedValue-boundary-check"] If _value_ is ‚â• 2<sup>31</sup>, throw an error.
      1. Return _sign_ √ó _value_.
    </emu-alg>
    <emu-note>
      The check in step <emu-xref href="#step-VLQSignedValue-boundary-check"></emu-xref> is needed because _unsigned_ is the VLQUnsignedValue of |VlqDigitList|, not of |Vlq|.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-VLQUnsignedValue" type="sdo">
    <h1>VLQUnsignedValue ( ): an non-negative integer</h1>
    <dl class="header"></dl>
    <emu-grammar>
      Vlq :: VlqDigitList
    </emu-grammar>
    <emu-alg>
      1. Let _value_ be the VLQUnsignedValue of |VlqDigitList|.
      1. If _value_ is ‚â• 2<sup>32</sup>, throw an error.
      1. Return _value_.
    </emu-alg>
    <emu-grammar>
      VlqDigitList ::
        ContinuationDigit VlqDigitList
    </emu-grammar>
    <emu-alg>
      1. Let _left_ be the VLQUnsignedValue of |ContinuationDigit|.
      1. Let _right_ be the VLQUnsignedValue of |VlqDigitList|.
      1. Return _left_ + _right_ √ó 2<sup>5</sup>.
    </emu-alg>
    <emu-grammar>
      TerminalDigit ::
        `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R`
        `S` `T` `U` `V` `W` `X` `Y` `Z` `a` `b` `c` `d` `e` `f`
    </emu-grammar>
    <emu-alg>
      1. Let _digit_ be the character matched by this production.
      1. Let _value_ be the integer corresponding to _digit_, according to the <emu-xref href="#sec-references-informative">base64</emu-xref> encoding as defined by IETF RFC 4648.
      1. Assert: _value_ &lt; 32.
      1. Return _value_.
    </emu-alg>
    <emu-grammar>
      ContinuationDigit ::
        `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x`
        `y` `z` `0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `+` `/`
    </emu-grammar>
    <emu-alg>
      1. Let _digit_ be the character matched by this production.
      1. Let _value_ be the integer corresponding to _digit_, according to the <emu-xref href="#sec-references-informative">base64</emu-xref> encoding as defined by IETF RFC 4648.
      1. Assert: 32 ‚â§ _value_ &lt; 64.
      1. Return _value_ - 32.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-json-values-utilities">
  <h1>JSON values utilities</h1>

  <p>While this specification's algorithms are defined on top of ECMA-262 internals, it is meant to be easily implementable by non-JavaScript platforms. This section contains utilities for working with JSON values, abstracting away ECMA-262 details from the rest of the document.</p>

  <p>A <dfn id="type-json-value" variants="JSON values">JSON value</dfn> is either a JSON object, a JSON array, a <emu-xref href="#sec-ecmascript-language-types-string-type">String</emu-xref>, a <emu-xref href="#sec-ecmascript-language-types-number-type">Number</emu-xref>, a <emu-xref href="#sec-ecmascript-language-types-boolean-type">Boolean</emu-xref>, or <emu-xref href="#sec-ecmascript-language-types-null-type">*null*</emu-xref>.</p>

  <p>A <dfn id="type-json-object">JSON object</dfn> is an Object such that each of its properties:</p>
  <ul>
    <li>is a data property,</li>
    <li>has a String key,</li>
    <li>has JSON value value.</li>
  </ul>

  <p>A <dfn id="type-json-array">JSON array</dfn> is a JSON object such that:</p>
  <ul>
    <li>it has a property whose key is *"length"* and whose value is a Number,</li>
    <li>all its other properties' keys are integer indices.</li>
  </ul>

  <emu-clause id="sec-ParseJSON" type="abstract operation">
    <h1>
      ParseJSON (
        _string_: a String,
      ): a JSON value
    </h1>
    <dl class="header"></dl>
    <emu-alg>
      1. Let _result_ be Call(<emu-xref href="#sec-json.parse">%JSON.parse%</emu-xref>, *null*, ¬´ _string_ ¬ª).
      1. Assert: _result_ is a JSON value.
      1. Return _result_.
    </emu-alg>

    <emu-note type="editor">
      This abstract operation is in the process of being exposed by ECMA-262 itself, at <a href="https://github.com/tc39/ecma262/pull/3540">tc39/ecma262#3540</a>.
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-JSONObjectGet" type="abstract operation">
    <h1>
      JSONObjectGet (
        _object_: a JSON object,
        _key_: a String,
      ): a JSON value or ~missing~
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It returns the value associated with the specified _key_ in _object_.</dd>
    </dl>
    <emu-alg>
      1. If _object_ does not have an own property with key _key_, return ~missing~.
      1. Let _prop_ be _object_'s own property whose key is _key_.
      1. Return _prop_'s [[Value]] attribute.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-JSONArrayIterate" type="abstract operation">
    <h1>
      JSONArrayIterate (
        _array_: a JSON array,
      ): a List of JSON values
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It returns a List containing all elements of _array_, so that it can be iterated by algorithms using "For each".</dd>
    </dl>
    <emu-alg>
      1. Let _length_ be JSONObjectGet(_array_, *"length"*).
      1. Assert: _length_ is a non-negative integral Number.
      1. Let _list_ be a new empty List.
      1. Let _i_ be 0.
      1. Repeat, while _i_ &lt; ‚Ñù(_length_),
        1. Let _value_ be JSONObjectGet(_array_, ToString(ùîΩ(_i_))).
        1. Assert: _value_ is not ~missing~.
        1. Append _value_ to _list_.
        1. Set _i_ to _i_ + 1.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-StringSplit" type="abstract operation">
    <h1>
      StringSplit (
        _string_: a String,
        _separators_: a List of String,
      ): a List of Strings
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It splits the string in substrings separated by any of the elements of _separators_. If multiple separators match, those appearing first in _separators_ have higher priority.</dd>
    </dl>
    <emu-alg>
      1. Let _parts_ be a new empty List.
      1. Let _strLen_ be the length of _string_.
      1. Let _lastStart_ be 0.
      1. Let _i_ be 0.
      1. Repeat, while _i_ &lt; _strLen_,
        1. Let _matched_ be *false*.
        1. For each String _sep_ of _separators_, do
          1. Let _sepLen_ be the length of _sep_.
          1. Let _candidate_ be the substring of _string_ from _i_ to min(_i_ + _sepLen_, _strLen_).
          1. If _candidate_ = _sep_ and _matched_ is *false*, then
            1. Let _chunk_ be the substring of _string_ from _lastStart_ to _i_.
            1. Append _chunk_ to _parts_.
            1. Set _lastStart_ to _i_ + _sepLen_.
            1. Set _i_ to _i_ + _sepLen_.
            1. Set _matched_ to *true*.
        1. If _matched_ is *false*, set _i_ to _i_ + 1.
      1. Let _chunk_ be the substring of _string_ from _lastStart_ to _strLen_.
      1. Append _chunk_ to _parts_.
      1. Return _parts_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-position-types">
  <h1>Position types</h1>

  <emu-clause id="sec-position-record-type">
    <h1>Position Record</h1>
    <p>A <dfn>Position Record</dfn> is a tuple of a non-negative line and non-negative column number:</p>
    <emu-table id="table-position-record-fields" caption="Position Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value Type</th>
          </tr>
        </thead>
        <tr>
          <td>[[Line]]</td>
          <td>a non-negative integral Number</td>
        </tr>
        <tr>
          <td>[[Column]]</td>
          <td>a non-negative integral Number</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-original-position-record-type">
    <h1>Original Position Record</h1>
    <p>A <dfn variants="Original Position Records">Original Position Record</dfn> is a tuple of a Decoded Source Record, a non-negative line and non-negative column number. It is similar to a Position Record but describes a source position in a concrete original source file.</p>
    <emu-table id="table-original-position-record-fields" caption="Original Position Record Fields">
      <table>
        <thead>
          <tr>
            <th>Field Name</th>
            <th>Value Type</th>
          </tr>
        </thead>
        <tr>
          <td>[[Source]]</td>
          <td>a Decoded Source Record</td>
        </tr>
        <tr>
          <td>[[Line]]</td>
          <td>a non-negative integral Number</td>
        </tr>
        <tr>
          <td>[[Column]]</td>
          <td>a non-negative integral Number</td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-ComparePositions" type="abstract operation">
    <h1>
      ComparePositions (
        _first_: a Position Record or a Original Position Record,
        _second_: a Position Record or a Original Position Record,
      ): ~lesser~, ~equal~ or ~greater~
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>It returns ~lesser~, ~equal~ or ~greater~ depending whether _first_ occurs before, is equal or occurs after _second_ respectively. The [[Source]] field of Original Position Records are ignored.</dd>
    </dl>
    <emu-alg>
      1. If _first_.[[Line]] &lt; _second_.[[Line]], return ~lesser~.
      1. If _first_.[[Line]] > _second_.[[Line]], return ~greater~.
      1. Assert: _first_.[[Line]] is equal to _second_.[[Line]].
      1. If _first_.[[Column]] &lt; _second_.[[Column]], return ~lesser~.
      1. If _first_.[[Column]] > _second_.[[Column]], return ~greater~.
      1. Return ~equal~.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-source-map-format">
  <h1>Source map format</h1>

  <p>A source map is a JSON document containing a top-level JSON object with the following structure:</p>
  <pre><code class="json">
  {
    "version" : 3,
    "file": "out.js",
    "sourceRoot": "",
    "sources": ["foo.js", "bar.js"],
    "sourcesContent": [null, null],
    "names": ["src", "maps", "are", "fun"],
    "mappings": "A,AAAB;;ABCDE",
    "ignoreList": [0]
  }
  </code></pre>
  <ul>
    <li>The <dfn id="json-version"><code>version</code> field</dfn> shall always be the number 3 as an integer. The source map may be rejected if the field has any other value.</li>
    <li>The <dfn id="json-file"><code>file</code> field</dfn> is an optional name of the generated code that this source map is associated with. It's not specified if this can be an URL, relative path name, or just a base name. Source map generators may choose the appropriate interpretation for their contexts of use.</li>
    <li>The <dfn id="json-sourceRoot"><code>sourceRoot</code> field</dfn> is an optional source root string, used for relocating source files on a server or removing repeated values in the sources entry. This value is prepended to the individual entries in the sources field.</li>
    <li>The <dfn id="json-sources"><code>sources</code> field</dfn> is a list of original sources used by the mappings field. Each entry is either a string that is a (potentially relative) URL or *null* if the source name is not known.</li>
    <li>The <dfn id="json-sourcesContent"><code>sourcesContent</code> field</dfn> is an optional list of source content (i.e. the original source) strings, used when the source cannot be hosted. The contents are listed in the same order as in the sources field. Entries may be *null* if some <emu-xref href="#sec-terms-and-definitions-original-source">original sources</emu-xref> should be retrieved by name.</li>
    <li>The <dfn id="json-names"><code>names</code> field</dfn> is an optional list of symbol names which may be used by the mappings field.</li>
    <li>The <dfn id="json-mappings"><code>mappings</code> field</dfn> is a string with the encoded mapping data (see section <emu-xref href="#sec-mappings"></emu-xref>).</li>
    <li>The <dfn id="json-ignoreList"><code>ignoreList</code> field</dfn> is an optional list of indices of files that should be considered third party code, such as framework code or bundler-<emu-not-ref>generated code</emu-not-ref>. This allows developer tools to avoid code that developers likely don't want to see or step through, without requiring developers to configure this beforehand. It refers to the sources field and lists the indices of all the known third-party sources in the source map. Some browsers may also use the deprecated `x_google_ignoreList` field if `ignoreList` is not present.</li>
    <li><ins>The <dfn id="json-scopes"><code>scopes</code> field</dfn> is an optional string with encoded scopes data (see section <emu-xref href="#sec-scopes"></emu-xref>)</ins></li>
  </ul>

  <emu-clause id="sec-decoding-source-maps">
    <h1>Decoding source maps</h1>

    <p>A <dfn id="decoded-source-map-record" variants="Decoded Source Map Records">Decoded Source Map Record</dfn> has the following fields:</p>
    <emu-table id="table-decoded-source-map-fields" caption="Fields of Decoded Source Map Records">
      <table>
        <thead>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
          </tr>
        </thead>
        <tr>
          <td>[[File]]</td>
          <td>a String or *null*</td>
        </tr>
        <tr>
          <td>[[Sources]]</td>
          <td>a List of Decoded Source Records</td>
        </tr>
        <tr>
          <td>[[Mappings]]</td>
          <td>a List of Decoded Mapping Records</td>
        </tr>
        <tr>
          <td><ins>[[Ranges]]</ins></td>
          <td><ins>a List of Generated Range Records</ins></td>
        </tr>
      </table>
    </emu-table>

    <p>A <dfn id="decoded-source-record" variants="Decoded Source Records">Decoded Source Record</dfn> has the following fields:</p>
    <emu-table id="table-decoded-source-fields" caption="Fields of Decoded Source Records">
      <table>
        <thead>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
          </tr>
        </thead>
        <tr>
          <td>[[URL]]</td>
          <td>a URL or *null*</td>
        </tr>
        <tr>
          <td>[[Content]]</td>
          <td>a String or *null*</td>
        </tr>
        <tr>
          <td>[[Ignored]]</td>
          <td>a Boolean</td>
        </tr>
        <tr>
          <td><ins>[[Scope]]</ins></td>
          <td><ins>a Original Scope Record or *null*</ins></td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-ParseSourceMap" type="abstract operation">
      <h1>
        ParseSourceMap (
          _string_: a String,
          _baseURL_: an URL,
        ): a Decoded Source Map Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _json_ be ParseJSON(_string_).
        1. If _json_ is not a JSON object, throw an error.
        1. If JSONObjectGet(_json_, *"sections"*) is not ~missing~, then
          1. Return DecodeIndexSourceMap(_json_, _baseURL_).
        1. Return DecodeSourceMap(_json_, _baseURL_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-DecodeSourceMap" type="abstract operation">
      <h1>
        DecodeSourceMap (
          _json_: a JSON object,
          _baseURL_: an URL,
        ): a Decoded Source Map Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. If JSONObjectGet(_json_, *"version"*) is not *3*<sub>ùîΩ</sub>, optionally report an error.
        1. Let _mappingsField_ be JSONObjectGet(_json_, *"mappings"*).
        1. If _mappingsField_ is not a String, throw an error.
        1. If JSONObjectGet(_json_, *"sources"*) is not a JSON array, throw an error.
        1. Let _fileField_ be GetOptionalString(_json_, *"file"*).
        1. Let _sourceRootField_ be GetOptionalString(_json_, *"sourceRoot"*).
        1. Let _sourcesField_ be GetOptionalListOfOptionalStrings(_json_, *"sources"*).
        1. Let _sourcesContentField_ be GetOptionalListOfOptionalStrings(_json_, *"sourcesContent"*).
        1. Let _ignoreListField_ be GetOptionalListOfArrayIndexes(_json_, *"ignoreList"*).
        1. Let _namesField_ be GetOptionalListOfStrings(_json_, *"names"*).
        1. <ins>Let _scopesField_ be GetOptionalString(_json_, *"scopes"*).</ins>
        1. <ins>Let _scopesAndRanges_ be DecodeScopesInfo(_scopesField_, _namesField_).</ins>
        1. <ins>Let _sources_ be DecodeSourceMapSources(_baseURL_, _sourceRootField_, _sourcesField_, _sourcesContentField_, _ignoreListField_, _scopesAndRanges_.[[Scopes]]).</ins>
        1. <ins>Let _mappings_ be DecodeMappings(_mappingsField_, _namesField_, _sources_).</ins>
        1. <ins>Return the Decoded Source Map Record { [[File]]: _fileField_, [[Sources]]: _sources_, [[Mappings]]: _mappings_, [[Ranges]]: _scopesAndRanges_.[[Ranges]] }.</ins>
      </emu-alg>

      <emu-clause id="sec-GetOptionalString" type="abstract operation">
        <h1>
          GetOptionalString (
            _object_: a JSON object,
            _key_: a String,
          ): a String or *null*
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _value_ be JSONObjectGet(_object_, _key_).
          1. If _value_ is a String, return _value_.
          1. If _value_ is not ~missing~, optionally report an error.
          1. Return *null*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-GetOptionalListOfStrings" type="abstract operation">
        <h1>
          GetOptionalListOfStrings (
            _object_: a JSON object,
            _key_: a String,
          ): a List of Strings
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _list_ be a new empty List.
          1. Let _values_ be JSONObjectGet(_object_, _key_).
          1. If _values_ is ~missing~, return _list_.
          1. If _values_ is not a JSON array, then
            1. Optionally report an error.
            1. Return _list_.
          1. For each element _item_ of JSONArrayIterate(_values_), do
            1. If _item_ is a String, then
              1. Append _item_ to _list_.
            1. Else,
              1. Optionally report an error.
              1. Append *""* to _list_.
          1. Return _list_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-GetOptionalListOfOptionalStrings" type="abstract operation">
        <h1>
          GetOptionalListOfOptionalStrings (
            _object_: a JSON object,
            _key_: a String,
          ): a List of either Strings or *null*
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _list_ be a new empty List.
          1. Let _values_ be JSONObjectGet(_object_, _key_).
          1. If _values_ is ~missing~, return _list_.
          1. If _values_ is not a JSON array, then
            1. Optionally report an error.
            1. Return _list_.
          1. For each element _item_ of JSONArrayIterate(_values_), do
            1. If _item_ is a String, then
              1. Append _item_ to _list_.
            1. Else,
              1. If _item_ ‚â† *null*, optionally report an error.
              1. Append *null* to _list_.
          1. Return _list_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-GetOptionalListOfArrayIndexes" type="abstract operation">
        <h1>
          GetOptionalListOfArrayIndexes (
            _object_: an Object,
            _key_: a String,
          ): a List of non-negative integers
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _list_ be a new empty List.
          1. Let _values_ be JSONObjectGet(_object_, _key_).
          1. If _values_ is ~missing~, return _list_.
          1. If _values_ is not a JSON array, then
            1. Optionally report an error.
            1. Return _list_.
          1. For each element _item_ of JSONArrayIterate(_values_), do
            1. If _item_ is an integral Number, _item_ ‚â† *+0*<sub>ùîΩ</sub>, and _item_ ‚â• *+0*<sub>ùîΩ</sub>, then
              1. Append ‚Ñù(_item_) to _list_.
            1. Else,
              1. If _item_ ‚â† *null*, optionally report an error.
              1. Append *null* to _list_.
          1. Return _list_.
        </emu-alg>
        <!--
           TODO:
          Should the "If _item_ ‚â† *null*, optionally report an error" step be
          removed, so that the list only contains numbers?
        -->
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-mappings">
    <h1>Mappings structure</h1>

    <p>The mappings field data is broken down as follows:</p>
    <ul>
      <li>each group representing a line in the generated file is separated by a semicolon (`;`)</li>
      <li>each segment is separated by a comma (`,`)</li>
      <li>each segment is made up of 1, 4, or 5 variable length fields.</li>
    </ul>
    <p>The fields in each segment are:</p>
    <ol>
      <li>The zero-based starting column of the line in the generated code that the segment represents. If this is the first field of the first segment, or the first segment following a new generated line (`;`), then this field holds the whole base64 VLQ. Otherwise, this field contains a base64 VLQ that is relative to the previous occurrence of this field. <em>Note that this is different from the subsequent fields below because the previous value is reset after every generated line.</em></li>
      <li>If present, the zero-based index into the sources list. This field contains a base64 VLQ relative to the previous occurrence of this field, unless it is the first occurrence of this field, in which case the whole value is represented.</li>
      <li>If present, the zero-based starting line in the original source. This field contains a base64 VLQ relative to the previous occurrence of this field, unless it is the first occurrence of this field, in which case the whole value is represented. Shall be present if there is a source field.</li>
      <li>If present, the zero-based starting column of the line in the original source. This field contains a base64 VLQ relative to the previous occurrence of this field, unless it is the first occurrence of this field, in which case the whole value is represented. Shall be present if there is a source field.</li>
      <li>If present, the zero-based index into the names list associated with this segment. This field contains a base64 VLQ relative to the previous occurrence of this field, unless it is the first occurrence of this field, in which case the whole value is represented.</li>
    </ol>

    <emu-note>The purpose of this encoding is to reduce the source map size. VLQ encoding reduced source maps by 50% relative to the Source Map Revision 2 Proposal in tests performed using Google Calendar.</emu-note>

    <emu-note>Segments with one field are intended to represent generated code that is unmapped because there is no corresponding original source code, such as code that is generated by a compiler. Segments with four fields represent mapped code where a corresponding name does not exist. Segments with five fields represent mapped code that also has a mapped name.</emu-note>

    <emu-note>Using <emu-not-ref>file</emu-not-ref> offsets was considered but rejected in favor of using line/<emu-not-ref>column</emu-not-ref> data to avoid becoming misaligned with the original due to platform-specific line endings.</emu-note>

    <p>A <dfn id="decoded-mapping-record" variants="Decoded Mapping Records">Decoded Mapping Record</dfn> has the following fields:</p>
    <emu-table id="table-decoded-mapping-fields" caption="Fields of Decoded Mapping Records">
      <table>
        <thead>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
          </tr>
        </thead>
        <tr>
          <td>[[GeneratedPosition]]</td>
          <td>a Position Record</td>
        </tr>
        <tr>
          <td>[[OriginalPosition]]</td>
          <td>a Original Position Record or *null*</td>
        </tr>
        <tr>
          <td>[[Name]]</td>
          <td>a String or *null*</td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-mappings-grammar">
      <h1>Mappings grammar</h1>
      <p>The mappings String must adhere to the following grammar:</p>

      <emu-grammar type="definition">
        MappingsField :
          LineList

        LineList :
          Line
          Line `;` LineList

        Line :
          MappingList?

        MappingList :
          Mapping
          Mapping `,` MappingList

        Mapping :
          GeneratedColumn
          GeneratedColumn OriginalSource OriginalLine OriginalColumn Name?

        GeneratedColumn :
          Vlq

        OriginalSource :
          Vlq

        OriginalLine :
          Vlq

        OriginalColumn :
          Vlq

        Name :
          Vlq
      </emu-grammar>

      <p>A <dfn id="decode-mapping-state-record" variants="Decode Mapping State Records">Decode Mapping State Record</dfn> has the following fields:</p>
      <emu-table id="table-decode-mapping-state-fields" caption="Fields of Decode Mapping State Records">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
            </tr>
          </thead>
          <tr>
            <td>[[GeneratedLine]]</td>
            <td>a non-negative integer</td>
          </tr>
          <tr>
            <td>[[GeneratedColumn]]</td>
            <td>a non-negative integer</td>
          </tr>
          <tr>
            <td>[[SourceIndex]]</td>
            <td>a non-negative integer</td>
          </tr>
          <tr>
            <td>[[OriginalLine]]</td>
            <td>a non-negative integer</td>
          </tr>
          <tr>
            <td>[[OriginalColumn]]</td>
            <td>a non-negative integer</td>
          </tr>
          <tr>
            <td>[[NameIndex]]</td>
            <td>a non-negative integer</td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-DecodeMappingsField" type="sdo">
        <h1>
          DecodeMappingsField (
            _state_: a Decode Mapping State Record,
            _mappings_: a List of Decoded Mapping Records,
            _names_: a List of Strings,
            _sources_: a List of Decoded Source Records,
          )
        </h1>
        <dl class="header"></dl>
        <emu-grammar>
          LineList :
            Line `;` LineList
        </emu-grammar>
        <emu-alg>
          1. Perform DecodeMappingsField of |Line| with arguments _state_, _mappings_, _names_ and _sources_.
          1. Set _state_.[[GeneratedLine]] to _state_.[[GeneratedLine]] + 1.
          1. Set _state_.[[GeneratedColumn]] to 0.
          1. Perform DecodeMappingsField of |LineList| with arguments _state_, _mappings_, _names_ and _sources_.
        </emu-alg>
        <emu-grammar>
          MappingList :
            Mapping `,` MappingList
        </emu-grammar>
        <emu-alg>
          1. Perform DecodeMappingsField of |Mapping| with arguments _state_, _mappings_, _names_ and _sources_.
          1. Perform DecodeMappingsField of |MappingList| with arguments _state_, _mappings_, _names_ and _sources_.
        </emu-alg>
        <emu-grammar>
          Mapping :
            GeneratedColumn
        </emu-grammar>
        <emu-alg>
          1. Perform DecodeMappingsField of |GeneratedColumn| with arguments _state_, _mappings_, _names_ and _sources_.
          1. If _state_.[[GeneratedColumn]] &lt; 0, then
            1. Optionally report an error.
            1. Return.
          1. Let _position_ be a new Position Record { [[Line]]: _state_.[[GeneratedLine]], [[Column]]: _state_.[[GeneratedColumn]] }.
          1. Let _decodedMapping_ be a new DecodedMappingRecord { [[GeneratedPosition]]: _position_, [[OriginalPosition]]: *null*, [[Name]]: *null* }.
          1. Append _decodedMapping_ to _mappings_.
        </emu-alg>
        <emu-grammar>
          Mapping :
            GeneratedColumn OriginalSource OriginalLine OriginalColumn Name?
        </emu-grammar>
        <emu-alg>
          1. Perform DecodeMappingsField of |GeneratedColumn| with arguments _state_, _mappings_, _names_ and _sources_.
          1. If _state_.[[GeneratedColumn]] &lt; 0, then
            1. Optionally report an error.
            1. Return.
          1. Let _generatedPosition_ be a new Position Record { [[Line]]: _state_.[[GeneratedLine]], [[Column]]: _state_.[[GeneratedColumn]] }.
          1. Perform DecodeMappingsField of |OriginalSource| with arguments _state_, _mappings_, _names_ and _sources_.
          1. Perform DecodeMappingsField of |OriginalLine| with arguments _state_, _mappings_, _names_ and _sources_.
          1. Perform DecodeMappingsField of |OriginalColumn| with arguments _state_, _mappings_, _names_ and _sources_.
          1. If _state_.[[SourceIndex]] &lt; 0 or _state_.[[SourceIndex]] ‚â• the number of elements of _sources_ or _state_.[[OriginalLine]] &lt; 0 or _state_.[[OriginalColumn]] &lt; 0, then
            1. Optionally report an error.
            1. Let _originalPosition_ be *null*.
          1. Else,
            1. Let _originalPosition_ be a new Original Position Record { [[Source]]: _sources_[_state_.[[SourceIndex]]], [[Line]]: _state_.[[OriginalLine]], [[Column]]: _state_.[[OriginalColumn]] }.
          1. Let _name_ be *null*.
          1. If |Name| is present, then
            1. Perform DecodeMappingsField of |Name| with arguments _state_, _mappings_, _names_ and _sources_.
            1. If _state_.[[NameIndex]] &lt; 0 or _state_.[[NameIndex]] ‚â• the number of elements of _names_, optionally report an error.
            1. Else, set _name_ to _names_[_state_.[[NameIndex]]].
          1. Let _decodedMapping_ be a new DecodedMappingRecord { [[GeneratedPosition]]: _generatedPosition_, [[OriginalPosition]]: _originalPosition_, [[Name]]: _name_ }.
          1. Append _decodedMapping_ to _mappings_.
        </emu-alg>
        <emu-grammar>
          GeneratedColumn :
            Vlq
        </emu-grammar>
        <emu-alg>
          1. Let _relativeColumn_ be the VLQSignedValue of |Vlq|.
          1. Set _state_.[[GeneratedColumn]] to _state_.[[GeneratedColumn]] + _relativeColumn_.
        </emu-alg>
        <emu-grammar>
          OriginalSource :
            Vlq
        </emu-grammar>
        <emu-alg>
          1. Let _relativeSourceIndex_ be the VLQSignedValue of |Vlq|.
          1. Set _state_.[[SourceIndex]] to _state_.[[SourceIndex]] + _relativeSourceIndex_.
        </emu-alg>
        <emu-grammar>
          OriginalLine :
            Vlq
        </emu-grammar>
        <emu-alg>
          1. Let _relativeLine_ be the VLQSignedValue of |Vlq|.
          1. Set _state_.[[OriginalLine]] to _state_.[[OriginalLine]] + _relativeLine_.
        </emu-alg>
        <emu-grammar>
          OriginalColumn :
            Vlq
        </emu-grammar>
        <emu-alg>
          1. Let _relativeColumn_ be the VLQSignedValue of |Vlq|.
          1. Set _state_.[[OriginalColumn]] to _state_.[[OriginalColumn]] + _relativeColumn_.
        </emu-alg>
        <emu-grammar>
          Name :
            Vlq
        </emu-grammar>
        <emu-alg>
          1. Let _relativeName_ be the VLQSignedValue of |Vlq|.
          1. Set _state_.[[NameIndex]] to _state_.[[NameIndex]] + _relativeName_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-DecodeMappings" type="abstract operation">
      <h1>
        DecodeMappings (
          _rawMappings_: a String,
          _names_: a List of Strings,
          _sources_: a List of Decoded Source Records,
        ): a List of Decoded Mapping Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _mappings_ be a new empty List.
        1. Let _mappingsNode_ be the root Parse Node when parsing _rawMappings_ using |MappingsField| as the goal symbol.
        1. If parsing failed, then
          1. Optionally report an error.
          1. Return _mappings_.
        1. Let _state_ be a new Decode Mapping State Record with all fields set to 0.
        1. Perform DecodeMappingsField of _mappingsNode_ with arguments _state_, _mappings_, _names_ and _sources_.
        1. Return _mappings_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-mappings-for-generated-javascript-code">
      <h1>Mappings for generated JavaScript code</h1>

      <p>Generated code positions that may have <emu-xref href="#decoded-mapping-record">mapping</emu-xref> entries are defined in terms of <em>input elements</em>, as per the <a href="https://tc39.es/ecma262/#sec-ecmascript-language-lexical-grammar">ECMAScript Lexical Grammar</a>. Mapping entries shall point to either:</p>
      <ul>
        <li>the first code point of the source text matched by |IdentifierName|, |PrivateIdentifier|, |Punctuator|, |DivPunctuator|, |RightBracePunctuator|, |NumericLiteral| and |RegularExpressionLiteral|.</li>
        <li>any code point of the source text matched by |Comment|, |HashbangComment|, |StringLiteral|, |Template|, |TemplateSubstitutionTail|, |WhiteSpace| and |LineTerminator|.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-names-for-generated-javascript-code">
      <h1>Names for generated JavaScript code</h1>

      <p>Source map generators should create a <emu-xref href="#decoded-mapping-record">mapping</emu-xref> entry with a [[Name]] field for a JavaScript token, if:</p>
      <ul>
        <li>The original source language construct maps semantically to the generated JavaScript code.</li>
        <li>The original source language construct has a name.</li>
      </ul>
      <p>Then the [[Name]] of the <emu-xref href="#decoded-mapping-record">mapping</emu-xref> entry should be the name of the original source language construct. A <emu-xref href="#decoded-mapping-record">mapping</emu-xref> with a non-null [[Name]] is called a <dfn variant="named mappings">named mapping</dfn>.</p>

      <emu-note example>
        A minifier renaming functions and variables or removing function names from immediately invoked function expressions.
      </emu-note>

      <p>The following enumeration lists productions of the <a href="https://tc39.es/ecma262/#sec-syntactic-grammar">ECMAScript Syntactic Grammar</a> and the respective token or non-terminal (on the right-hand side of the production) for which source map generators should emit a named mapping. The <emu-xref href="#decoded-mapping-record">mapping</emu-xref> entry created for such tokens shall follow section <emu-xref href="#sec-mappings-for-generated-javascript-code"></emu-xref>.</p>

      <p>The enumeration should be understood as the "minimum". In general, source map generators are free to emit any additional named mappings.</p>

      <emu-note>
        The enumeration also lists tokens where generators "may" emit named mappings in addition to the tokens where they "should". These reflect the reality where existing tooling emits or expects named mappings. The duplicated named mapping is comparably cheap: Indices into names are encoded relative to each other so subsequent mappings to the same name are encoded as 0 (`A`).
      </emu-note>

      <ul>
        <li>
          <p>The |BindingIdentifier|(s) for |LexicalDeclaration|, |VariableStatement| and |FormalParameterList|.</p>
        </li>
        <li>
          <p>The |BindingIdentifier| for |FunctionDeclaration|, |FunctionExpression|, |AsyncFunctionDeclaration|, |AsyncFunctionExpression|, |GeneratorDeclaration|, |GeneratorExpression|, |AsyncGeneratorDeclaration|, and |AsyncGeneratorExpression| if it exists, or the opening parenthesis `(` preceding the |FormalParameters| otherwise.</p>

          <p>
            Source map generators may chose to emit a named mapping on the opening parenthesis regardless of
            the presence of the |BindingIdentifier|.
          </p>
        </li>
        <li>
          <p>For an |ArrowFunction| or |AsyncArrowFunction|:</p>
          <ul>
            <li>
              <p>The `=>` token where |ArrowFunction| is produced with a single |BindingIdentifier| for |ArrowParameters| or |AsyncArrowFunction| is produced with an |AsyncArrowBindingIdentifier|.</p>
              <emu-note>This describes the case of (async) arrow functions with a single parameter, where that single parameter is not wrapped in parenthesis.</emu-note>
            </li>
            <li>
              <p>The opening parenthesis `(` where |ArrowFunction| or |AsyncArrowFunction| is produced with |ArrowFormalParameters|.</p>
              <p>Source map generators may chose to additionally emit a named mapping on the `=>` token for consistency with the previous case.</p>
            </li>
          </ul>
        </li>
        <li>
          <p>The |ClassElementName| for |MethodDefinition|. This includes generators, async methods, async generators and accessors. For |MethodDefinition| where |ClassElementName| is *"constructor"*, the [[Name]] should be the original class name if applicable.</p>
          <p>Source map generators may chose to additionally emit a named mapping on the opening parenthesis `(`.</p>
        </li>
        <li>
          <p>Source map generators may emit named mapping for |IdentifierReference| in |Expression|.</p>
        </li>
      </ul>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-scopes">
    <h1>Scopes structure</h1>

    <p>The scope information is split across two data structures: original scopes and generated ranges. Original scopes describe the scope tree for original sources. Generated ranges describe where these scopes are found in the generated code. The scope information includes location information, for both original scopes and generated ranges, the type and name of a scope, as well as the original names of variables and how to retrieve their values in the generated code.</p>

    <p>The scopes field is a comma (`,`) separated list of items. Each item is a list of base64 VLQs. The first base64 VLQ in each item is a tag that specifies which item is described by the rest of the VLQs. Items encode the original scope and generated range trees in prefix order.</p>

    <emu-clause id="sec-original-scope-record-type">
      <h1>Original Scope Record</h1>
      <p>A original scope is described by a <dfn variants="Original Scope Records">Original Scope Record</dfn>:</p>
      <emu-table id="table-original-scope-record-fields" caption="Original Scope Record Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tr>
            <td>[[Start]]</td>
            <td>a Position Record</td>
            <td>The line and column (inclusive) where this scope starts.</td>
          </tr>
          <tr>
            <td>[[End]]</td>
            <td>a Position Record</td>
            <td>The line and column (exclusive) where this scope ends.</td>
          </tr>
          <tr>
            <td>[[Name]]</td>
            <td>a String or *null*</td>
            <td>The original name of this scope. E.g. the original class or function name.</td>
          </tr>
          <tr>
            <td>[[Kind]]</td>
            <td>a String or *null*</td>
            <td>Debuggers may use [[Kind]] to label this scope in a scope view UI. It is purely informative for users.</td>
          </tr>
          <tr>
            <td>[[IsStackFrame]]</td>
            <td>a Boolean</td>
            <td>Signifies whether this scope is something that can be called, e.g. a function or method.</td>
          </tr>
          <tr>
            <td>[[Variables]]</td>
            <td>a List of Strings</td>
            <td>The original variable names declared in this scope.</td>
          </tr>
          <tr>
            <td>[[Children]]</td>
            <td>a List of Original Scope Records</td>
            <td>The child scopes of this scope.</td>
          </tr>
        </table>
      </emu-table>
      <p>A root Original Scope Record describes the lexical scope tree of a original source file.</p>
      <emu-note>
        In case the original source language is JavaScript or JavaScript-like, source map generators are encouraged to use the terms <em>Block</em>, <em>Function</em>, <em>Script</em>/<em>Module</em> and <em>Global</em> for the [[Kind]] field where it makes sense.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-generated-range-record-type">
      <h1>Generated Range Record</h1>
      <p>A generated range is described by a <dfn variants="Generated Range Records">Generated Range Record</dfn>:</p>
      <emu-table id="table-generated-range-record-fields" caption="Generated Range Record Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tr>
            <td>[[Start]]</td>
            <td>a Position Record</td>
            <td>The line and column (inclusive) where this range starts.</td>
          </tr>
          <tr>
            <td>[[End]]</td>
            <td>a Position Record</td>
            <td>The line and column (exclusive) where this range ends.</td>
          </tr>
          <tr>
            <td>[[Definition]]</td>
            <td>a Original Scope Record or *null*</td>
            <td>The corresponding original scope</td>
          </tr>
          <tr>
            <td>[[IsStackFrame]]</td>
            <td>a Boolean</td>
            <td>Whether this generated range is a JavaScript/Wasm function.</td>
          </tr>
          <tr>
            <td>[[IsHidden]]</td>
            <td>a Boolean</td>
            <td>Whether this generated range is a compiler/transpiler inserted JavaScript/Wasm function even though [[Definition]] is not *null*. E.g. a original block scope was transpiled to a JS function. If [[IsHidden]] is *true*, then [[IsStackFrame]] must also be true.</td>
          </tr>
          <tr>
            <td>[[Bindings]]</td>
            <td>a List of either Strings or *null*</td>
            <td>A list of JavaScript expressions that when evaluated in this generated range, evaluates to the value of the corresponding variable. *null* indicates that the variable is unavailable in this range.</td>
          </tr>
          <tr>
            <td>[[SubRangeBindings]]</td>
            <td>a List of Sub-Range Binding Records</td>
            <td>Variables that require different expression throughout this range to retrieve its value specify [[SubRangeBindings]].</td>
          </tr>
          <tr>
            <td>[[CallSite]]</td>
            <td>a Original Position Record or *null*</td>
            <td>The presence of [[CallSite]] signifies that this generated range represents an inlined original scope body. [[Definition]] must contain a valid reference and the Original Scope Record behind [[Definition]] must have the value *true* in it's [[IsStackFrame]] field.</td>
          </tr>
          <tr>
            <td>[[Children]]</td>
            <td>a List of Generated Range Records</td>
            <td>The child ranges of this range.</td>
          </tr>
        </table>
      </emu-table>
      <p>A root Decoded Generated Record describes a distinct part of the generated code. Each Generated Range Record may be associated with a Original Scope Record as indicated by the presence of the [[Definition]] field.</p>
      <p>[[Bindings]] are intended for debuggers to retrieve the values of original variables. The length of [[Bindings]] must be equal to [[Variables]] of the corresponding Original Scope Record. Given an index i, the JavaScript expression [[Binding]][i], when evaluated inside the generated range, retrieves the value for the original variable [[Variables]][i].</p>
      <p>If a variable requires different expressions across a generated range, then [[SubRangeBindings]] can be used. [[SubRangeBinding]] splits the generated range into multiple sub-ranges, but just for a specific variable. Note that the same can be achieved with splitting the whole generated range, but at the cost of duplicating all of the information.</p>
      <p>If a variable utilizes [[SubRangeBindings]] then the expression for the first sub-range is found in [[Bindings]] and the rest in [[SubRangeBindings]].</p>
      <emu-note example>
        Let _range_ be a Generated Range Record that starts at "0:0" (line 0, column 0) and ends at "0:30". The corresponding Original Scope Record contains a single variable "foo". The value of "foo" can be retrieved via the expression "a" in the range ["0:0", "0:10"). "foo" is unavailable in the range ["0:10", "0:20") and in the range ["0:20", "0:30") the expression "b" must be used. Then _range_ looks like:
        <pre><code>
          {
            [[Start]]: { [[Line]]: 0, [[Column]]: 0 },
            [[End]]: { [[Line]]: 0, [[Column]]: 30 },
            [[Definition]]: { ... }
            [[Bindings]]: ["a"]
            [[SubRangeBindings]]: [
              {
                [[From]]: { [[Line]]: 0, [[Column]]: 10 },
                [[Binding]]: *null*,
              },
              {
                [[From]]: { [[Line]]: 0, [[Column]]: 20 },
                [[Binding]]: "b",
              },
            ],
          }
        </code></pre>
      </emu-note>
      <p>A non-*null* [[CallSite]] field marks the generated range as an inlined scope. If the [[CallSite]] field of a generated range is not *null*, then:</p>
      <ul>
        <li>[[Definition]] must not be *null*.</li>
        <li>[[Definition]].[[IsStackFrame]] must be *true*.</li>
        <li>[[IsStackFrame]] must be *false*.</li>
      </ul>

      <emu-clause id="sec-sub-range-binding-record-type">
        <h1>The Sub-Range Binding Record</h1>
        <p>The <dfn variant="Sub-Range Binding Records">Sub-Range Binding Record</dfn> describe a variable that requires different JavaScript expressions in different parts of a generated range to retrieve the variables value.</p>
        <emu-table id="table-sub-range-binding-record-fields" caption="Sub-Range Binding Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[Variable]]</td>
              <td>a String</td>
              <td>The variable for which these expressions must be used to retrieve its value. [[Variable]] must be contained in the [[Definition]].[[Variables]] List. That is it must be valid variable in the corresponding Original Scope Record.</td>
            </tr>
            <tr>
              <td>[[Bindings]]</td>
              <td>a List of Binding Records</td>
              <td>A list of position and expression tuples that describe from which position a specific expression must be used to retrieve this variables' value.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-binding-record-type">
        <h1>The Binding Record</h1>
        <p>The <dfn variant="Binding Records">Binding Record</dfn> describes a JavaScript expression that must be used for the given position to retrieve a specific variables' value.</p>
        <emu-table id="table-binding-record-fields" caption="Binding Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>[[From]]</td>
              <td>a Position Record</td>
              <td>Use [[Binding]] from this position until either the next [[From]] or the ranges' end position to retrieve this variables' value.</td>
            </tr>
            <tr>
              <td>[[Binding]]</td>
              <td>a String</td>
              <td>The expression to use to retrieve this variables' value.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-scopes-grammar">
      <h1>Scopes grammar</h1>
      <p>The scopes field is described by the following <em>context-sensitive</em> grammar starting at the |Scopes| goal symbol:</p>
      <emu-grammar type="definition">
        Scopes :
          OriginalScopeTreeList
          TopLevelItemList
          OriginalScopeTreeList `,` TopLevelItemList

        OriginalScopeTreeList :
          OriginalScopeTreeItem
          OriginalScopeTreeList `,` OriginalScopeTreeItem

        OriginalScopeTreeItem :
          OriginalScopeTree
          [empty]

        TopLevelItemList :
          TopLevelItem
          TopLevelItemList `,` TopLevelItem

        TopLevelItem :
          GeneratedRangeTree
          UnknownItem
      </emu-grammar>

      <p>The number of |OriginalScopeTreeItem|s in the |OriginalScopeTreeList| is expected to match the length of the sources field. The n-th |OriginalScopeTreeItem| describes the scope tree of the n-th authored source file in the sources field. If no scope information is available for a particular source URL, an empty item can be used.</p>

      <emu-note example>
        <p>A source map with three authored sources where only the first and third source file have scope information available would be encoded as:</p>
        <pre>
          "scopes": "&lt;OriginalScopeTree&gt;,,&lt;OriginalScopeTree&gt;,&lt;GeneratedRangeTree&gt;"
        </pre>
      </emu-note>

      <emu-clause id="sec-original-scope-grammar">
        <h1>Original scope grammar</h1>
        <p>Each original scope consists of:</p>
        <ul>
          <li>a |OriginalScopeStart| item describing the start location and general scope information.</li>
          <li>an optional |OriginalScopeVariablesItem| describing the original names of the variables this scope declares.</li>
          <li>an optional list of |OriginalScopeTree|s describing child scopes.</li>
          <li>a |OriginalScopeEnd| item describing the end location.</li>
        </ul>
        <p>In grammar form:</p>
        <emu-grammar type="definition">
          OriginalScopeTree :
            OriginalScopeStart OriginalScopeVariablesItem? OriginalScopeItemList? `,` OriginalScopeEnd

          OriginalScopeVariablesItem :
            `,` OriginalScopeVariables

          OriginalScopeItemList :
            `,` OriginalScopeItem
            OriginalScopeItemList `,` OriginalScopeItem

          OriginalScopeItem :
            OriginalScopeTree
            UnknownItem

          OriginalScopeStart :
            `B` ScopeFlags ScopeLine ScopeColumn ScopeName? ScopeKind?

          OriginalScopeEnd :
            `C` ScopeLine ScopeColumn

          OriginalScopeVariables :
            `D` ScopeVariableList

          ScopeVariableList :
            ScopeVariable
            ScopeVariableList ScopeVariable

          ScopeFlags :
            Vlq

          ScopeLine :
            Vlq

          ScopeColumn :
            Vlq

          ScopeName :
            Vlq

          ScopeKind :
            Vlq

          ScopeVariable :
            Vlq
        </emu-grammar>
        <p>The VLQUnsignedValue of |ScopeFlags| encodes the presence of |ScopeName| and |ScopeKind| and marks the scope as a function:</p>
        <emu-table id="table-scope-flags" caption="|ScopeFlags| bits">
          <table>
            <thead>
              <tr>
                <th>Bit Mask</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>0x1</td>
              <td>Set if |ScopeName| is present.</td>
            </tr>
            <tr>
              <td>0x2</td>
              <td>Set if |ScopeKind| is present.</td>
            </tr>
            <tr>
              <td>0x4</td>
              <td>Mark this scope as something callable. That is the [[IsStackFrame]] field is set to *true*.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-generated-range-grammar">
        <h1>Generated range grammar</h1>
        <p>Each generated range consists of:</p>
        <ul>
          <li>a |GeneratedRangeStart| item describing the start location and general range information.</li>
          <li>an optional |GeneratedRangeCallSiteItem|. The presence marks this generated range as an inlined function body and the |GeneratedRangeCallSite| describes the location where this function was called in the original source.</li>
          <li>an optional |GeneratedRangeBindingsItem| containing the JavaScript expressions to retrieve the values of the corresponding scopes' variables.</li>
          <li>an optional list of |GeneratedSubRangeBinding|s. A variable might require different JavaScript expression to retrieve its value throughout this generated range. Or a variable might not be available in only parts of a range.</li>
          <li>an optional list of |GeneratedRangeTree|s describing child ranges.</li>
        </ul>
        <p>In grammar form:</p>
        <emu-grammar type="definition">
          GeneratedRangeTree :
            GeneratedRangeStart GeneratedRangeBindingsItem? GeneratedRangeCallSiteItem? GeneratedRangeItemList? `,` GeneratedRangeEnd

          GeneratedRangeBindingsItem :
            `,` GeneratedRangeBindings

          GeneratedRangeCallSiteItem :
            `,` GeneratedRangeCallSite

          GeneratedRangeItemList :
            `,` GeneratedRangeItem
            GeneratedRangeItemList `,` GeneratedRangeItem

          GeneratedRangeItem :
            GeneratedSubRangeBinding
            GeneratedRangeTree
            UnknownItem

          GeneratedRangeStart :
            `E` RangeFlags RangeLine? RangeColumn RangeDefinition?

          GeneratedRangeEnd :
            `F` RangeLine? RangeColumn

          GeneratedRangeBindings :
            `G` RangeBindingsList

          RangeBindingsList :
            RangeBinding
            RangeBindingsList RangeBinding

          GeneratedSubRangeBinding :
            `H` VariableIndex BindingFromList

          BindingFromList :
            BindingFrom
            BindingFromList BindingFrom

          BindingFrom :
            BindingLine BindingColumn Vlq

          GeneratedRangeCallSite :
            `I` CallSiteSourceIdx CallSiteLine CallSiteColumn

          RangeFlags :
            Vlq

          RangeLine :
            Vlq

          RangeColumn :
            Vlq

          RangeDefinition :
            Vlq

          RangeBinding :
            Vlq

          VariableIndex :
            Vlq

          BindingLine :
            Vlq

          BindingColumn :
            Vlq

          CallSiteSourceIdx :
            Vlq

          CallSiteLine :
            Vlq

          CallSiteColumn :
            Vlq
        </emu-grammar>
        <p>The VLQUnsignedValue of |RangeFlags| encodes the presence of |RangeLine| and |RangeDefinition|. All used bits:</p>
        <emu-table id="table-range-flags" caption="|RangeFlags| bits">
          <table>
            <thead>
              <tr>
                <th>Bit Mask</th>
                <th>Meaning</th>
              </tr>
            </thead>
            <tr>
              <td>0x1</td>
              <td>Set if |RangeLine| is present.</td>
            </tr>
            <tr>
              <td>0x2</td>
              <td>Set if |RangeDefinition| is present.</td>
            </tr>
            <tr>
              <td>0x4</td>
              <td>If set, then this range as a JavaScript/WASM function in the generated code. This includes methods, accessors, arrow functions, constructors, etc. Any JavaScript language construct that can be called and will result in a stack frame. If set, the [[IsStackFrame]] field is set to *true*.</td>
            </tr>
            <tr>
              <td>0x8</td>
              <td>Only valid if the 0x4 ([[IsStackFrame]]) is also set. Marks this range as a outlined function. E.g. a transpiler translated a block scope into a function. Any call to this range should be hidden in translated stack traces.</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-unknown-item-grammar">
        <h1>Unknown item grammar</h1>
        <p>Complying implementations are expected to decode but ignore items with unknown tags. This allows the specification to add new items in the future, without breaking existing decoders.</p>
        <emu-grammar type="definition">
          UnknownItem :
            Tag
            Tag UnknownVlqList

          Tag :
            Vlq but not `A` `B` `C` `D` `E` `F` `G` `H` `I`

          UnknownVlqList :
            Vlq
            UnknownVlqList Vlq
        </emu-grammar>
        <emu-note>
          The specification reserves all tags for future use. Vendors wanting to experiment are encouraged to use high enough tag numbers for vendor specific items.
        </emu-note>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-decoding-scopes">
      <h1>Decoding scopes</h1>
      <p>The scopes grammar defined in <emu-xref href="#sec-scopes-grammar"></emu-xref> is context-sensitive and heavily utilizes relative numbers to reduce the bytes required for the encoded scope information. As such, the grammar alone is not enough to describe how a |Scopes| parse node is turned into Original Scope Records and Generated Range Records.</p>

      <emu-clause id="sec-scope-info-record-type">
        <h1>Scope Info Record</h1>
        <p>The <dfn>Scope Info Record</dfn> is a specification type and is the result of decoding the scopes field.</p>
        <emu-table id="table-scope-info-record-fields" caption="Scope Info Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value Type</th>
              </tr>
            </thead>
            <tr>
              <td>[[Scopes]]</td>
              <td>a List of either Original Scope Records or *null*</td>
            </tr>
            <tr>
              <td>[[Ranges]]</td>
              <td>a List of Generated Range Records</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-decode-scope-state-record-type">
        <h1>Decode Scope State Record</h1>
        <p>The <dfn>Decode Scope State Record</dfn> is a specification type that tracks absolute values of decoded fields.</p>
        <emu-table id="table-decode-scope-state-record-fields" caption="Decode Scope State Record Fields">
          <table>
            <thead>
              <tr>
                <th>Field Name</th>
                <th>Value</th>
                <th>Meaning / Production</th>
              </tr>
            </thead>
            <tr>
              <td>[[FlatOriginalScopes]]</td>
              <td>a List of Original Scope Records</td>
              <td>This is a list of Original Scope Records in order as seen while decoding. This is equivalent to a prefix walk of the [[Scopes]] field in the Scope Info Record. The |RangeDefinition| is an index into this List.</td>
            </tr>
            <tr>
              <td>[[ScopeLine]]</td>
              <td>a non-negative Number</td>
              <td>|ScopeLine|</td>
            </tr>
            <tr>
              <td>[[ScopeColumn]]</td>
              <td>a non-negative Number</td>
              <td>|ScopeColumn|</td>
            </tr>
            <tr>
              <td>[[ScopeNameIndex]]</td>
              <td>a non-negative Number</td>
              <td>|ScopeName|</td>
            </tr>
            <tr>
              <td>[[ScopeKindIndex]]</td>
              <td>a non-negative Number</td>
              <td>|ScopeKind|</td>
            </tr>
            <tr>
              <td>[[ScopeVariableIndex]]</td>
              <td>a non-negative Number</td>
              <td>|ScopeVariable|</td>
            </tr>
            <tr>
              <td>[[RangeLine]]</td>
              <td>a non-negative Number</td>
              <td>|RangeLine|</td>
            </tr>
            <tr>
              <td>[[RangeColumn]]</td>
              <td>a non-negative Number</td>
              <td>|RangeColumn|</td>
            </tr>
            <tr>
              <td>[[RangeDefinitionIndex]]</td>
              <td>a non-negative Number</td>
              <td>|RangeDefinition|</td>
            </tr>
            <tr>
              <td>[[SubRangeLine]]</td>
              <td>a non-negative Number</td>
              <td>|BindingLine|</td>
            </tr>
            <tr>
              <td>[[SubRangeColumn]]</td>
              <td>a non-negative Number</td>
              <td>|BindingColumn|</td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-DecodeScopesInfo" type="abstract operation">
        <h1>
          DecodeScopesInfo (
            _scopes_: a String or *null*,
            _names_: a List of Strings,
          ): a Scope Info Record
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _result_ be a new Scope Info Record { [[Scopes]]: ¬´ ¬ª, [[Records]]: ¬´ ¬ª }.
          1. If _scopes_ is *null*, return _result_.
          1. Let _parsedScopes_ be the root Parse Node when parsing _scopes_ using |Scopes| as the goal symbol.
          1. If parsing failed, then
            1. Optionally report an error.
            1. Return _result_.
          1. Let _state_ be a new Decode Scope State Record { [[FlatScopes]]: ¬´ ¬ª, [[ScopeLine]]: 0, [[ScopeColumn]]: 0, [[ScopeNameIndex]]: 0, [[ScopeKindIndex]]: 0, [[ScopeVariableIndex]]: 0, [[RangeLine]]: 0, [[RangeColumn]]: 0, [[RangeDefinitionIndex]]: 0, [[SubRangeLine]]: 0, [[SubRangeColumn]]: 0 }.
          1. Perform DecodeScopesInfoItem of _parsedScopes_ with arguments _result_, _state_ and _names_.
          1. Return _result_.
        </emu-alg>

        <emu-clause id="sec-DecodeScopesInfoItem" type="sdo">
          <h1>
            DecodeScopesInfoItem (
              _info_: a Scope Info Record,
              _state_: a Decode Scope State Record,
              _names_: a List of Strings,
            )
          </h1>
          <dl class="header"></dl>
          <emu-grammar>
            Scopes :
              OriginalScopeTreeList `,` TopLevelItemList
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeScopesInfoItem of |OriginalScopeTreeList| with arguments _info_, _state_ and _names_.
            1. Perform DecodeScopesInfoItem of |TopLevelItemList| with arguments _info_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            OriginalScopeTreeList :
              OriginalScopeTreeList `,` OriginalScopeTreeItem
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeScopesInfoItem of |OriginalScopeTreeList| with arguments _info_, _state_ and _names_.
            1. Perform DecodeScopesInfoItem of |OriginalScopeTreeItem| with arguments _info_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            OriginalScopeTreeItem :
              OriginalScopeTree
          </emu-grammar>
          <emu-alg>
            1. Set _state_.[[ScopeLine]] to 0.
            1. Set _state_.[[ScopeColumn]] to 0.
            1. Let _scope_ be DecodeOriginalScope(|OriginalScopeTree|, _state_, _names_).
            1. Append _scope_ to _info_.[[Scopes]].
          </emu-alg>
          <emu-grammar>
            OriginalScopeTreeItem :
              [empty]
          </emu-grammar>
          <emu-alg>
            1. Append *null* to _info_.[[Scopes]].
          </emu-alg>
          <emu-grammar>
            TopLevelItemList :
              TopLevelItemList `,` TopLevelItem
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeScopesInfoItem of |TopLevelItemList| with arguments _info_, _state_ and _names_.
            1. Perform DecodeScopesInfoItem of |TopLevelItem| with arguments _info_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            TopLevelItem :
              GeneratedRangeTree
          </emu-grammar>
          <emu-alg>
            1. Let _range_ be DecodeGeneratedRange(|GeneratedRangeTree|, _state_, _names_).
            1. Append _range_ to _info_.[[Ranges]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-DecodeOriginalScope" type="abstract operation">
        <h1>
          DecodeOriginalScope (
            _scopeTree_: a |OriginalScopeTree| Parse Node,
            _state_: a Decode Scope State Record,
            _names_: a List of Strings,
          ): a Original Scope Record
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _scope_ be a new Original Scope Record with all fields default initialized.
          1. Perform DecodeOriginalScopeItem of _scopeTree_ with arguments _scope_, _state_ and _names_.
          1. Append _scope_ to _state_.[[FlatScopes]].
          1. Return _scope_.
        </emu-alg>

        <emu-clause id="sec-DecodeOriginalScopeItem" type="sdo">
          <h1>
            DecodeOriginalScopeItem (
              _scope_: a Original Scope Record,
              _state_: a Decode Scope State Record,
              _names_: a List of Strings,
            )
          </h1>
          <dl class="header"></dl>
          <emu-grammar>
            OriginalScopeTree :
              OriginalScopeStart OriginalScopeVariablesItem? OriginalScopeItemList? `,` OriginalScopeEnd
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeOriginalScopeItem of |OriginalScopeStart| with arguments _scope_, _state_ and _names_.
            1. If |OriginalScopeVariablesItem| is present, perform DecodeOriginalScopeItem of |OriginalScopeVariablesItem| with arguments _scope_, _state_ and _names_.
            1. If |OriginalScopeItemList| is present, perform DecodeOriginalScopeItem of |OriginalScopeItemList| with arguments _scope_, _state_ and _names_.
            1. Perform DecodeOriginalScopeItem of |OriginalScopeEnd| with arguments _scope_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            OriginalScopeStart :
              `B` ScopeFlags ScopeLine ScopeColumn ScopeName? ScopeKind?
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeOriginalScopeItem of |ScopeLine| with arguments _scope_, _state_ and _names_.
            1. Set _scope_.[[Start]].[[Line]] to _state_.[[ScopeLine]].
            1. Perform DecodeOriginalScopeItem of |ScopeColumn| with arguments _scope_, _state_ and _names_.
            1. Set _scope_.[[Start]].[[Column]] to _state_.[[ScopeColumn]].
            1. Let _flags_ be the VLQUnsignedValue of |ScopeFlags|.
            1. Assert: |ScopeName| is present if and only if, _flags_ & 0x1 = 0x1.
            1. If |ScopeName| is present, perform DecodeOriginalScopeItem of |ScopeName| with arguments _scope_, _state_ and _names_.
            1. Assert: |ScopeKind| is present if and only if, _flags_ & 0x2 = 0x2.
            1. If |ScopeKind| is present, perform DecodeOriginalScopeItem of |ScopeKind| with arguments _scope_, _state_ and _names_.
            1. If _flags_ & 0x4 = 0x4, set _scope_.[[IsStackFrame]] to *true*.
          </emu-alg>
          <emu-grammar>
            ScopeVariableList :
              ScopeVariableList ScopeVariable
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeOriginalScopeItem of |ScopeVariableList| with arguments _scope_, _state_ and _names_.
            1. Perform DecodeOriginalScopeItem of |ScopeVariable| with arguments _scope_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            OriginalScopeItemList :
              OriginalScopeItemList `,` OriginalScopeItem
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeOriginalScopeItem of |OriginalScopeItemList| with arguments _scope_, _state_ and _names_.
            1. Perform DecodeOriginalScopeItem of |OriginalScopeItem| with arguments _scope_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            OriginalScopeItem :
              OriginalScopeTree
          </emu-grammar>
          <emu-alg>
            1. Let _childScope_ be DecodeOriginalScope(|OriginalScopeTree|, _state_, _names_).
            1. Append _childScope_ to _scope_.[[Children]].
          </emu-alg>
          <emu-grammar>
            OriginalScopeEnd :
              `C` ScopeLine ScopeColumn
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeOriginalScopeItem of |ScopeLine| with arguments _scope_, _state_ and _names_.
            1. Set _scope_.[[End]].[[Line]] to _state_.[[ScopeLine]].
            1. Perform DecodeOriginalScopeItem of |ScopeColumn| with arguments _scope_, _state_ and _names_.
            1. Set _scope_.[[End]].[[Column]] to _state_.[[ScopeColumn]].
          </emu-alg>
          <emu-grammar>
            ScopeLine :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeLine_ be the VLQUnsignedValue of |Vlq|.
            1. Set _state_.[[ScopeLine]] to _state_.[[ScopeLine]] + _relativeLine_.
            1. [id="step-reset-scope-column"] If _relativeLine_ > 0, set _state_.[[ScopeColumn]] to 0.
          </emu-alg>
          <emu-note>
            Step <emu-xref href="#step-reset-scope-column"></emu-xref> makes it so |ScopeColumn| is encoded relative if the preceding |OriginalScopeStart| or |OriginalScopeEnd| is on the same line (i.e. _relativeLine_ is 0), or absolute otherwise.
          </emu-note>
          <emu-grammar>
            ScopeColumn :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeColumn_ be the VLQUnsignedValue of |Vlq|.
            1. Set _state_.[[ScopeColumn]] to _state_.[[ScopeColumn]] + _relativeColumn_.
          </emu-alg>
          <emu-grammar>
            ScopeName :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeName_ be the VLQSignedValue of |Vlq|.
            1. Set _state_.[[ScopeNameIndex]] to _state_.[[ScopeNameIndex]] + _relativeName_.
            1. Set _scope_.[[Name]] to _names_[_state_.[[ScopeNameIndex]]].
          </emu-alg>
          <emu-grammar>
            ScopeKind :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeKind_ be the VLQSignedValue of |Vlq|.
            1. Set _state_.[[ScopeKindIndex]] to _state_.[[ScopeKindIndex]] + _relativeKind_.
            1. Set _scope_.[[Kind]] to _names_[_state_.[[ScopeKindIndex]]].
          </emu-alg>
          <emu-grammar>
            ScopeVariable :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeVariable_ be the VLQSignedValue of |Vlq|.
            1. Set _state_.[[ScopeVariableIndex]] to _state_.[[ScopeVariableIndex]] + _relativeVariable_.
            1. Append _names_[_state_.[[ScopeVariableIndex]]] to _scope_.[[Variables]].
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-DecodeGeneratedRange" type="abstract operation">
        <h1>
          DecodeGeneratedRange (
            _rangeTree_: a |GeneratedRangeTree| Parse Node,
            _state_: a Decode Scope State Record,
            _names_: a List of Strings,
          ): a Generated Range Record
        </h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _range_ be a new Generated Range Record with all fields default initialized.
          1. Perform DecodeGeneratedRangeItem of _rangeTree_ with arguments _range_, _state_ and _names_.
          1. Return _range_.
        </emu-alg>

        <emu-clause id="sec-DecodeGeneratedRangeItem" type="sdo">
          <h1>
            DecodeGeneratedRangeItem (
              _range_: a Generated Range Record,
              _state_: a Decode Scope State Record,
              _names_: a List of Strings,
            )
          </h1>
          <dl class="header"></dl>
          <emu-grammar>
            GeneratedRangeTree :
              GeneratedRangeStart GeneratedRangeBindingsItem? GeneratedRangeCallSiteItem? GeneratedRangeItemList? `,` GeneratedRangeEnd
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeGeneratedRangeItem of |GeneratedRangeStart| with arguments _range_, _state_ and _names_.
            1. If |GeneratedRangeBindingsItem| is present, perform DecodeGeneratedRangeItem of |GeneratedRangeBindingsItem| with arguments _range_, _state_ and _names_.
            1. If |GeneratedRangeCallSiteItem| is present, perform DecodeGeneratedRangeItem of |GeneratedRangeCallSiteItem| with arguments _range_, _state_ and _names_.
            1. If |GeneratedRangeItemList| is present, perform DecodeGeneratedRangeItem of |GeneratedRangeItemList| with arguments _range_, _state_ and _names_.
            1. Perform DecodeGeneratedRangeItem of |GeneratedRangeEnd| with arguments _range_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            GeneratedRangeItemList :
              GeneratedRangeItemList `,` GeneratedRangeItem
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeGeneratedRangeItem of |GeneratedRangeItemList| with arguments _range_, _state_ and _names_.
            1. Perform DecodeGeneratedRangeItem of |GeneratedRangeItem| with arguments _range_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            GeneratedRangeItem :
              GeneratedRangeTree
          </emu-grammar>
          <emu-alg>
            1. Let _childRange_ be DecodeGeneratedRange(|GeneratedRangeTree|, _state_, _names_).
            1. Append _childRange_ to _range_.[[Children]].
          </emu-alg>
          <emu-grammar>
            GeneratedRangeStart :
              `E` RangeFlags RangeLine? RangeColumn RangeDefinition?
          </emu-grammar>
          <emu-alg>
            1. Let _flags_ be the VLQUnsignedValue of |RangeFlags|.
            1. Assert: |RangeLine| is present if and only if, _flags_ & 0x1 = 0x1.
            1. If |RangeLine| is present, perform DecodeGeneratedRangeItem of |RangeLine| with arguments _range_, _state_ and _names_.
            1. Set _range_.[[Start]].[[Line]] to _state_.[[RangeLine]].
            1. Perform DecodeGeneratedRangeItem of |RangeColumn| with arguments _range_, _state_ and _names_.
            1. Set _range_.[[Start]].[[Column]] to _state_.[[RangeColumn]].
            1. Assert: |RangeDefinition| is present if and only if, _flags & 0x2 = 0x2.
            1. If |RangeDefinition| is present, perform DecodeGeneratedRangeItem of |RangeDefinition| with arguments _range_, _state_ and _names_.
            1. If _flags_ & 0x4 = 0x4, set _range_.[[IsStackFrame]] to *true*.
            1. If _flags_ & 0x8 = 0x8, set _range_.[[IsHidden]] to *true*.
          </emu-alg>
          <emu-grammar>
            GeneratedRangeEnd :
              `F` RangeLine? RangeColumn
          </emu-grammar>
          <emu-alg>
            1. If |RangeLine| is present, perform DecodeGeneratedRangeItem of |RangeLine| with arguments _range_, _state_ and _names_.
            1. Set _range_.[[End]].[[Line]] to _state_.[[RangeLine]].
            1. Perform DecodeGeneratedRangeItem of |RangeColumn| with arguments _range_, _state_ and _names_.
            1. Set _range_.[[End]].[[Column]] to _state_.[[RangeColumn]].
          </emu-alg>
          <emu-grammar>
            RangeBindingsList :
              RangeBindingsList RangeBinding
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeGeneratedRangeItem of |RangeBindingsList| with arguments _range_, _state_ and _names_.
            1. Perform DecodeGeneratedRangeItem of |RangeBindingsList| with arguments _range_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            GeneratedSubRangeBinding :
              `H` VariableIndex BindingFromList
          </emu-grammar>
          <emu-alg>
            1. [id="step-reset-subrange-line"] Set _state_.[[SubRangeLine]] to _range_.[[Start]].[[Line]].
            1. [id="step-reset-subrange-column"] Set _state_.[[SubRangeColumn]] to _range_.[[Start]].[[Column]].
            1. Let _variableIndex_ be the VLQUnsignedValue of |VariableIndex|.
            1. Let _variable_ be _range_.[[Definition]].[[Variables]][_variableIndex_].
            1. Let _subRangeBinding_ be a new Sub-Range Binding Record { [[Variable]]: _variable_, [[Binding]]: ¬´ ¬ª }.
            1. Perform DecodeSubRangeBinding of |BindingFromList| with arguments _subRangeBinding_, _state_ and _names_.
            1. Append _subRangeBinding_ to _range_.[[SubRangeBindings]].
          </emu-alg>
          <emu-note>
            Sub-range "from" positions are encoded relative to each other. Step <emu-xref href="#step-reset-subrange-line"></emu-xref> and <emu-xref href="#step-reset-subrange-line"></emu-xref> make it so that the first sub-range is relative to the ranges' start position.
          </emu-note>
          <emu-grammar>
            GeneratedRangeCallSite :
              `I` CallSiteSourceIdx CallSiteLine CallSiteColumn
          </emu-grammar>
          <emu-alg>
            1. Let _sourceIndex_ be the VLQUnsignedValue of |CallSiteSourceIdx|.
            1. Let _line_ be the VLQUnsignedValue of |CallSiteLine|.
            1. Let _column_ be the VLQUnsignedValue of |CallSiteColumn|.
            1. Set _range_.[[CallSite]] to a new Original Position Record { [[SourceIndex]]: _sourceIndex_, [[Line]]: _line_, [[Column]]: _column_ }.
          </emu-alg>
          <emu-grammar>
            RangeLine :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeLine_ be the VLQUnsignedValue of |Vlq|.
            1. Set _state_.[[RangeLine]] to _state_.[[RangeLine]] + _relativeLine_.
            1. [id="step-reset-range-column"] If _relativeLine_ > 0, set _state_.[[RangeColumn]] to 0.
          </emu-alg>
          <emu-note>
            Step <emu-xref href="#step-reset-range-column"></emu-xref> makes it so |RangeColumn| is encoded relative if the preceding |GeneratedRangeStart| or |GeneratedRangeEnd| is on the same line (i.e. _relativeLine_ is 0), or absolute otherwise.
          </emu-note>
          <emu-grammar>
            RangeColumn :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeColumn_ be the VLQUnsignedValue of |Vlq|.
            1. Set _state_.[[RangeColumn]] to _state_.[[RangeColumn]] + _relativeColumn_.
          </emu-alg>
          <emu-grammar>
            RangeDefinition :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeDefinition_ be the VLQSignedValue of |Vlq|.
            1. Set _state_.[[RangeDefinitionIndex]] to _state_.[[RangeDefinitionIndex]] + _relativeDefinition_.
            1. Set _range_.[[Definition]] to _state_.[[FlatOriginalScopes]][_state_.[[RangeDefinitionIndex]]].
          </emu-alg>
          <emu-grammar>
            RangeBinding :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _binding_ be the VLQSignedValue of |Vlq|.
            1. If _binding_ ‚â• 0, append _names_[_binding_] to _range_.[[Bindings]].
            1. Else, append *null* to _range_.[[Bindings]].
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-DecodeSubRangeBinding" type="sdo">
          <h1>
            DecodeSubRangeBinding (
              _subRangeBinding_: a Sub-Range Binding Record,
              _state_: a Decode Scope State Record,
              _names_: a List of Strings,
            )
          </h1>
          <dl class="header"></dl>
          <emu-grammar>
            BindingFromList :
              BindingFromList BindingFrom
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeSubRangeBinding of |BindingFromList| with arguments _subRangeBinding_, _state_ and _names_.
            1. Perform DecodeSubRangeBinding of |BindingFrom| with arguments _subRangeBinding_, _state_ and _names_.
          </emu-alg>
          <emu-grammar>
            BindingFrom :
              BindingLine BindingColumn Vlq
          </emu-grammar>
          <emu-alg>
            1. Perform DecodeSubRangeBinding of |BindingLine| with arguments _subRangeBinding_, _state_ and _names_.
            1. Perform DecodeSubRangeBinding of |BindingColumn| with arguments _subRangeBinding_, _state_ and _names_.
            1. Let _expressionIndex_ be the VLQUnsignedValue of |Vlq|.
            1. If _expressionIndex_ ‚â• 0, let _expression_ be _names_[_expressionIndex_].
            1. Else, let _expression_ be *null*.
            1. Let _binding_ be a new Binding Record { [[From]]: { [[Line]]: _state_.[[SubRangeLine]], [[Column]]: _state_.[[SubRangeColumn]] }, [[Binding]]: _expression_ }.
            1. Append _binding_ to _subRangeBinding_.[[Bindings]].
          </emu-alg>
          <emu-grammar>
            BindingLine :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeLine_ be the VLQUnsignedValue of |Vlq|.
            1. Set _state_.[[SubRangeLine]] to _state_.[[SubRangeLine]] + _relativeLine_.
            1. If _relativeLine_ > 0, set _state_.[[SubRangeColumn]] to 0.
          </emu-alg>
          <emu-grammar>
            BindingColumn :
              Vlq
          </emu-grammar>
          <emu-alg>
            1. Let _relativeColumn_ be the VLQUnsignedValue of |Vlq|.
            1. Set _state_.[[SubRangeColumn]] to _state_.[[SubRangeColumn]] + _relativeColumn_.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-sources">
    <h1>Resolving sources</h1>

    <p>If the sources are not absolute URLs after prepending the sourceRoot, the sources are resolved relative to the source map (like resolving the script `src` attribute in an HTML document).</p>

    <emu-clause id="sec-DecodeSourceMapSources" type="abstract operation">
      <h1>
        DecodeSourceMapSources (
          _baseURL_: an URL,
          _sourceRoot_: a String or *null*,
          _sources_: a List of either Strings or *null*,
          _sourcesContent_: a List of either Strings or *null*,
          _ignoreList_: a List of non-negative integers,
          <ins>_scopes_: a List of either Original Scope Records or *null*,</ins>
        ): a Decoded Source Record
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _decodedSources_ be a new empty List.
        1. Let _sourcesContentCount_ be the the number of elements in _sourcesContent_.
        1. Let _sourceUrlPrefix_ be *""*.
        1. If _sourceRoot_ ‚â† *null*, then
          1. If _sourceRoot_ ends with the code point U+002F (SOLIDUS), then
            1. Set _sourceUrlPrefix_ to _sourceRoot_.
          1. Else,
            1. Set _sourceUrlPrefix_ to the string-concatenation of _sourceRoot_ and *"/"*.
        1. Let _index_ be 0.
        1. Repeat, while _index_ &lt; _sources_' length,
          1. Let _source_ be _sources_[_index_].
          1. <ins>Let _decodedSource_ be the Decoded Source Record { [[URL]]: *null*, [[Content]]: *null*, [[Ignored]]: *false*, [[Scope]]: *null* }.</ins>
          1. If _source_ ‚â† *null*, then
            1. Set _source_ to the string-concatenation of _sourceUrlPrefix_ and _source_.
            1. Let _sourceURL_ be the result of URL parsing _source_ with _baseURL_.
            1. If _sourceURL_ is ~failure~, optionally report an error.
            1. Else, set _decodedSource_.[[URL]] to _sourceURL_.
          1. If _ignoreList_ contains _index_, set _decodedSource_.[[Ignored]] to *true*.
          1. If _sourcesContentCount_ > _index_, set _decodedSource_.[[Content]] to _sourcesContent_[_index_].
          1. <ins>If _index_ ‚â• 0 and _index &lt; _scopes_' length, then</ins>
            1. <ins>Set _decodedSource_.[[Scope]] to _scopes_.[_index_].</ins>
          1. Append _decodedSource_ to _decodedSources_.
        1. Return _decodedSources_.
      </emu-alg>

      <emu-note>Implementations that support showing source contents but do not support showing multiple sources with the same URL and different content will arbitrarily choose one of the various contents corresponding to the given URL.</emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-extensions">
    <h1>Extensions</h1>

    <p>Source map consumers shall ignore any additional unrecognized properties, rather than causing the source map to be rejected, so that additional features can be added to this format without breaking existing users.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-index-source-map">
  <h1>Index source map</h1>

  <p>To support concatenating generated code and other common post-processing, an alternate representation of a source map is supported:</p>

  <pre><code class="json">
  {
    "version" : 3,
    "file": "app.js",
    "sections": [
      {
        "offset": {"line": 0, "column": 0},
        "map": {
          "version" : 3,
          "file": "section.js",
          "sources": ["foo.js", "bar.js"],
          "names": ["src", "maps", "are", "fun"],
          "mappings": "AAAA,E;;ABCDE"
        }
      },
      {
        "offset": {"line": 100, "column": 10},
        "map": {
          "version" : 3,
          "file": "another_section.js",
          "sources": ["more.js"],
          "names": ["more", "is", "better"],
          "mappings": "AAAA,E;AACA,C;ABCDE"
        }
      }
    ]
  }
  </code></pre>

  <p>The index map follows the form of the standard map. Like the regular source map, the file format is JSON with a top-level object. It shares the version and file field from the regular source map, but gains a new sections field.</p>

  <p>The <dfn id="json-sections"><code>sections</code> field</dfn> is an array of objects with the following fields:</p>
  <ul>
    <li><dfn id="json-sections-offset"><code>offset</code> field</dfn> is an object with two fields, `line` and `column`, that represent the offset into generated code that the referenced source map represents.</li>
    <li><dfn id="json-sections-map"><code>map</code> field</dfn> is an embedded complete source map object. An embedded map does not inherit any values from the containing index map.</li>
  </ul>

  <p>The sections shall be sorted by starting position and the represented sections shall not overlap.</p>

  <emu-clause id="sec-DecodeIndexSourceMap" type="abstract operation">
    <h1>
      DecodeIndexSourceMap (
        _json_: an Object,
        _baseURL_: an URL,
      ): a Decoded Source Map Record
    </h1>
    <dl class="header"></dl>
    <emu-alg>
      1. Let _sectionsField_ be JSONObjectGet(_json_, *"sections"*).
      1. Assert: _sectionsField_ is not ~missing~.
      1. If _sectionsField_ is not a JSON array, throw an error.
      1. If JSONObjectGet(_json_, *"version"*) is not *3*<sub>ùîΩ</sub>, optionally report an error.
      1. Let _fileField_ be GetOptionalString(_json_, *"file"*).
      1. Let _sourceMap_ be the Decoded Source Map Record { [[File]]: _fileField_, [[Sources]]: ¬´ ¬ª, [[Mappings]]: ¬´ ¬ª }.
      1. Let _previousOffsetPosition_ be *null*.
      1. Let _previousLastMapping_ be *null*.
      1. For each JSON value _section_ of JSONArrayIterate(_sectionsField_), do
        1. If _section_ is not a JSON object, then
          1. Optionally report an error.
        1. Else,
          1. Let _offset_ be JSONObjectGet(_section_, *"offset"*).
          1. If _offset_ is not a JSON object, throw an error.
          1. Let _offsetLine_ be JSONObjectGet(_offset_, *"line"*).
          1. Let _offsetColumn_ be JSONObjectGet(_offset_, *"column"*).
          1. If _offsetLine_ is not an integral Number, then
            1. Optionally report an error.
            1. Set _offsetLine_ to *+0*<sub>ùîΩ</sub>.
          1. If _offsetColumn_ is not an integral Number, then
            1. Optionally report an error.
            1. Set _offsetColumn_ to *+0*<sub>ùîΩ</sub>.
          1. Let _offsetPosition_ be a new Position Record { [[Line]]: _offsetLine_, [[Column]]: _offsetColumn_ }.
          1. If _previousOffsetPosition_ ‚â† *null*, then
            1. If ComparePositions(_offsetPosition_, _previousOffsetPosition_) is ~lesser~, optionally report an error.
          1. If _previousLastMapping_ ‚â† *null*, then
            1. If ComparePositions(_offsetPosition_, _previousLastMapping_.[[GeneratedPosition]]) is ~lesser~, optionally report an error.
            1. NOTE: This part of the decoding algorithm checks that entries of the sections field of index source maps are ordered and do not overlap. While it is expected that generators should not produce index source maps with overlapping sections, source map consumers may, for example, only check the simpler condition that the section offsets are ordered.
          1. Let _mapField_ be JSONObjectGet(_section_, *"map"*).
          1. If _mapField_ is not a JSON object, throw an error.
          1. Let _decodedSectionCompletion_ be Completion(DecodeSourceMap(_json_, _baseURL_)).
          1. If _decodedSectionCompletion_ is a throw completion, then
            1. Optionally report an error.
          1. Else,
            1. Let _decodedSection_ be _decodedSectionCompletion_.[[Value]].
            1. For each Decoded Source Record _additionalSource_ of _decodedSection_.[[Sources]], do
              1. If _sourceMap_.[[Sources]] does not contain _additionalSource_, then
                1. Append _additionalSource_ to _sourceMap_.[[Sources]].
            1. Let _offsetMappings_ be a new empty List.
            1. For each Decoded Mapping Record _mapping_ of _decodedSection_.[[Mappings]], do
              1. If _mapping_.[[GeneratedPosition]].[[Line]] = 0, then
                1. Set _mapping_.[[GeneratedPosition]].[[Column]] to _mapping_.[[GeneratedPosition]].[[Column]] + _offsetColumn_.
              1. Set _mapping_.[[GeneratedPosition]].[[Line]] to _mapping_.[[GeneratedPosition]].[[Line]] + _offsetLine_.
              1. Append _mapping_ to _offsetMappings_.
            1. Set _sourceMap_.[[Mappings]] to the list-concatenation of _sourceMap_.[[Mappings]] and _offsetMappings_.
            1. Set _previousOffsetPosition_ to _offsetPosition_.
            1. [declared="a,b"] Let _sortedMappings_ be a copy of _offsetMappings_, sorted in ascending order, with a Decoded Mapping Record _a_ being less than a Decoded Mapping Record _b_ if ComparePositions(_a_.[[GeneratedPosition]], _b_.[[GeneratedPosition]]) is ~lesser~.
            1. If _sortedMappings_ is not empty, set _previousLastMapping_ to the last element of _sortedMappings_.
        1. Return _sourceMap_.
    </emu-alg>

    <emu-note>
      Implementations may choose to represent index source map sections without appending the mappings together, for example, by storing each section separately and conducting a binary search.
    </emu-note>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-retrieving-source-maps">
  <h1>Retrieving source maps</h1>

  <emu-clause id="sec-linking-generated-code">
    <h1>Linking generated code to source maps</h1>

    <p>While the source map format is intended to be language and platform agnostic, it is useful to define how to reference to them for the expected use-case of web server-hosted JavaScript.</p>
    <p>There are two possible ways to link source maps to the output. The first requires server support in order to add an HTTP header and the second requires an annotation in the source.</p>
    <p>Source maps are linked through URLs as defined in <emu-xref href="#sec-references-informative">WHATWG URL</emu-xref>; in particular, characters outside the set permitted to appear in URIs shall be percent-encoded and it may be a data URI. Using a data URI along with sourcesContent allows for a completely self-contained source map.</p>
    <p>The HTTP `sourcemap` header has precedence over a source annotation, and if both are present, the header URL should be used to resolve the source map file.</p>
    <p>Regardless of the method used to retrieve the source map URL the same process is used to resolve it, which is as follows.</p>
    <p>When the source map URL is not absolute, then it is relative to the generated code's <dfn id="source-origin">source origin</dfn>. The source origin is determined by one of the following cases:</p>
    <ul>
      <li>
        <p>If the generated source is not associated with a script element that has a `src` attribute and there exists a `//# sourceURL` comment in the generated code, that comment should be used to determine the source origin.</p>
        <emu-note>
          Previously, this was `//@ sourceURL`, as with `//@ sourceMappingURL`, it is reasonable to accept both but `//#` is preferred.
        </emu-note>
      </li>
      <li>If the generated code is associated with a script element and the script element has a `src` attribute, the `src` attribute of the script element will be the source origin.</li>
      <li>If the generated code is associated with a script element and the script element does not have a `src` attribute, then the source origin will be the page's origin.</li>
      <li>If the generated code is being evaluated as a string with the `eval()` function or via `new Function()`, then the source origin will be the page's origin.</li>
    </ul>

    <emu-clause id="sec-linking-http-header">
      <h1>Linking through HTTP headers</h1>

      <p>If a file is served through HTTP(S) with a `sourcemap` header, the value of the header is the URL of the linked source map.</p>
      <pre><code>sourcemap: &lt;url&gt;</code></pre>
      <emu-note>
        Previous revisions of this document recommended a header name of `x-sourcemap`. This is now deprecated; `sourcemap` is now expected.
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-linking-inline">
      <h1>Linking through inline annotations</h1>

      <p>The generated code should include a comment, or the equivalent construct depending on its language or format, named `sourceMappingURL` and that contains the URL of the source map. This specification defines how the comment should look like for JavaScript, CSS, and WebAssembly. Other languages should follow a similar convention.</p>

      <p>For a given language there can be multiple ways of detecting the `sourceMappingURL` comment, to allow for different implementations to choose what is less complex for them. The generated code <dfn id="umambiguous-linking">unambiguously links to a source map</dfn> if the result of all the extraction methods is the same.</p>

      <p>If a tool consumes one or more source files that unambiguously links to a source map and it produces an output file that links to a source map, it shall do so <emu-xref href="#umambiguous-linking">unambiguously</emu-xref>.</p>

      <emu-note example>
        <p>The following JavaScript code links to a source map, but it does not do so <emu-xref href="#umambiguous-linking">unambiguously</emu-xref>:</p>

        <pre><code class="javascript">let a = &#x60;
&#x2F;&#x2F;# sourceMappingURL=foo.js.map
&#x2F;&#x2F;&#x60;</code></pre>

        <p>Extracting a source map URL from it <emu-xref href="#sec-JavaScriptExtractSourceMapURL-through-parsing">through parsing</emu-xref> gives *null*, while <emu-xref href="#sec-JavaScriptExtractSourceMapURL-without-parsing">without parsing</emu-xref> gives `foo.js.map`.</p>
      </emu-note>

      <emu-note issue>
        <p>Having multiple ways to extract a source map URL, that can lead to different results, can have negative security and privacy implications. Implementations that need to detect which source maps are potentially going to be loaded are strongly encouraged to always apply both algorithms, rather than just assuming that they will give the same result.</p>

        <p>A fix to this problem is being worked on, and is expected to be included in a future version of the standard. It will likely involve early returning from the below algorithms whenever there is a comment (or comment-like) that contains the characters U+0060 (`), U+0022 ("), or U+0027 ('), or the the sequence U+002A U+002F (*/).</p>
      </emu-note>

      <emu-clause id="sec-JavaScriptExtractSourceMapURL" type="abstract operation">
        <h1>
          JavaScriptExtractSourceMapURL (
            _source_: a String,
          ): a String or *null*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It extracts a source map URL from a <strong>JavaScript</strong> source. It has two possible implementations: either <emu-xref href="#sec-JavaScriptExtractSourceMapURL-through-parsing">through parsing</emu-xref> or without parsing.</dd>
        </dl>

        <p>To extract a source map URL <dfn id="sec-JavaScriptExtractSourceMapURL-through-parsing">through parsing</dfn>:</p>

        <emu-alg>
          1. Let _tokens_ be the List of tokens obtained by parsing _source_ according to <emu-xref href="#sec-ecmascript-language-lexical-grammar">ECMA-262's lexical grammar</emu-xref>.
          1. For each nonterminal _token_ in _tokens_, in reverse order, do
            1. If _token_ is not |SingleLineComment| or |MultiLineComment|, return *null*.
            1. Let _comment_ be the content of _token_.
            1. Let _sourceMapURL_ be MatchSourceMapURL(_comment_).
            1. If _sourceMapURL_ is a String, return _sourceMapURL_.
          1. Return *null*.
        </emu-alg>
        <!-- TODO: We need to define a SDO for getting the contents of a comment, to make explicit what they actually are -->

        <p>To extract a source map URL <dfn id="sec-JavaScriptExtractSourceMapURL-without-parsing">without parsing</dfn>:</p>

        <emu-alg>
          1. Let _lines_ be StringSplit(_source_, ¬´ *"\u000D\u000A"*, *"\u000A"*, *"\u000D"*, *"\u2028"*, *"\u2029"* ¬ª).
          1. NOTE: The regular expression above matches the |LineTerminatorSequence| production.
          1. Let _lastURL_ be *null*.
          1. For each String _lineStr_ in _lines_, do
            1. Let _line_ be StringToCodePoints(_lineStr_).
            1. Let _position_ be 0.
            1. Let _lineLength_ be the length of _line_.
            1. Repeat, while _position_ &lt; _lineLength_,
              1. Let _first_ be _line_[_position_].
              1. Set _position_ to _position_ + 1.
              1. If _first_ is U+002F (SOLIDUS) and _position_ &lt; _lineLength_, then
                1. Let _second_ be _line_[_position_].
                1. Set _position_ to _position_ + 1.
                1. If _second_ is U+002F (SOLIDUS), then
                  1. Let _comment_ be the substring of _lineStr_ from _position_ to _lineLength_.
                  1. Let _sourceMapURL_ be MatchSourceMapURL(_comment_).
                  1. If _sourceMapURL_ is a String, set _lastURL_ to _sourceMapURL_.
                  1. Set _position_ to _lineLength_.
                1. Else if _second_ is U+002A (ASTERISK), then
                  1. Let _commentCp_ be a new empty List.
                  1. Repeat, while _position_ + 1 &lt; _lineLength_,
                    1. Let _c1_ be _line_[_position_].
                    1. Set _position_ to _position_ + 1.
                    1. Let _c2_ be _line_[_position_].
                    1. If _c1_ is U+002A (ASTERISK) and _c2_ is U+002F (SOLIDUS), then
                      1. Set _position_ to _position_ + 1.
                      1. Let _sourceMapURL_ be MatchSourceMapURL(CodePointsToString(_commentCp_)).
                      1. If _sourceMapURL_ is a String, set _lastURL_ to _sourceMapURL_.
                    1. Append _c1_ to _commentCp_.
                1. Else,
                  1. Set _lastURL_ to *null*.
              1. Else if _first_ is not an ECMAScript |WhiteSpace|, then
                1. Set _lastURL_ to *null*.
              1. NOTE: We reset _lastURL_ to *null* whenever we find a non-comment code character.
          1. Return _lastURL_.
        </emu-alg>
        <emu-note>
          The algorithm above has been designed so that the source lines can be iterated in reverse order, returning early after scanning through a line that contains a `sourceMappingURL` comment.
        </emu-note>
        <emu-note>
          <p>The algorithm above is equivalent to the following JavaScript implementation:</p>

          <pre><code class="javascript">const JS_NEWLINE = /^/m;

// This RegExp will always match one of the following:
// - single-line comments
// - "single-line" multi-line comments
// - unclosed multi-line comments
// - just trailing whitespaces
// - a code character
// The loop below differentiates between all these cases.
const JS_COMMENT =
  /\s*(?:\/\/(?&lt;single&gt;.*)|\/\*(?&lt;multi&gt;.*?)\*\/|\/\*.*|$|(?&lt;code&gt;[^\/]+))/uym;

const PATTERN = /^[@#]\s*sourceMappingURL=(\S*?)\s*$/;

let lastURL = null;
for (const line of source.split(JS_NEWLINE)) {
  JS_COMMENT.lastIndex = 0;
  while (JS_COMMENT.lastIndex &lt; line.length) {
    let commentMatch = JS_COMMENT.exec(line).groups;
    let comment = commentMatch.single ?? commentMatch.multi;
    if (comment != null) {
      let match = PATTERN.exec(comment);
      if (match !== null) lastURL = match[1];
    } else if (commentMatch.code != null) {
      lastURL = null;
    } else {
      // We found either trailing whitespaces or an unclosed comment.
      // Assert: JS_COMMENT.lastIndex === line.length
    }
  }
}
return lastURL;</code></pre>
        </emu-note>

        <emu-clause type="abstract operation" id="sec-MatchSourceMapURL">
          <h1>
            MatchSourceMapURL (
              _comment_: a String,
            ): either ~none~ or a String
          </h1>
          <dl class="header"></dl>
          <emu-alg>
            1. Let _pattern_ be RegExpCreate(*"^[@#]\\s\*sourceMappingURL=(\\S\*?)\\s\*$"*, *""*).
            1. Let _match_ be RegExpExec(_pattern_, _comment_).
            1. If _match_ is not *null*, return Get(_match_, *"1"*).
            1. Return ~none~.
          </emu-alg>

          <emu-note>The prefix for this annotation was initially `//@`, however this conflicts with Internet Explorer's Conditional Compilation and was changed to `//#`.</emu-note>

          <p>Source map generators shall only emit `//#`, while source map consumers shall accept both `//@` and `//#`.</p>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-CSSExtractSourceMapURL" type="abstract operation">
        <h1>
          CSSExtractSourceMapURL (
            _source_: a String,
          ): a String or *null*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It extracts a source map URL from a <strong>CSS</strong> source.</dd>
        </dl>
        <p>Extracting <span>source map URL</span>s from CSS is similar to JavaScript, with the exception that CSS only supports `/* ... */`-style comments.</p>
      </emu-clause>

      <emu-clause id="sec-WebAssemblyExtractSourceMapURL" type="abstract operation">
        <h1>
          WebAssemblyExtractSourceMapURL (
            _bytes_: a Data Block,
          ): a String or *null*
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It extracts a source map URL from a <strong>WebAssembly</strong> binary source.</dd>
        </dl>
      </emu-clause>
      <emu-alg>
        1. Let _module_ be module_decode(_bytes_).
        1. If _module_ is WebAssembly error, return *null*.
        1. For each custom section _customSection_ of _module_, do
          1. Let _name_ be the `name` of _customSection_.
          1. If CodePointsToString(_name_) is *"sourceMappingURL"*, then
            1. Let _value_ be the `bytes` of _customSection_.
            1. Return CodePointsToString(_value_).
        1. Return *null*.
      </emu-alg>

      <p>Since WebAssembly is not a textual format and it does not support comments, it supports a single unambiguous extraction method. The URL is encoded as a WebAssembly name, and it's placed as the content of the custom section. It is invalid for tools that generate WebAssembly code to generate two or more custom sections with the `sourceMappingURL` name.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-fetching-source-maps">
    <h1>Fetching source maps</h1>

    <emu-clause id="sec-FetchSourceMap" type="abstract operation">
      <h1>
        FetchSourceMap (
          _url_: an URL,
        ): a Promise
      </h1>
      <dl class="header"></dl>
      <emu-alg>
        1. Let _promiseCapability_ be NewPromiseCapability(%Promise%).
        1. Let _request_ be a new request whose request URL is _url_.
        1. Let _processResponseConsumeBody_ be a new Abstract Closure with parameters (_response_, _bodyBytes_) that captures _promiseCapability_ and _url_, and performs the following steps when called:
          1. If _bodyBytes_ is *null* or ~failure~, then
            1. Perform Call(_promiseCapability_.[[Reject]], *undefined*, ¬´ a new *TypeError* ¬ª).
            1. Return.
          1. If _url_'s scheme is an HTTP(S) scheme and the byte sequence \``)]}'`\` is a byte-sequence-prefix of _bodyBytes_, then
            1. Repeat, while _bodyBytes_'s byte-sequence-length ‚â† 0 and _bodyBytes_[0] is not an HTTP newline byte,
              1. Remove the 0th element from _bodyBytes_.
          1. Let _bodyString_ be Completion(UTF-8 decode of _bodyBytes_).
          1. IfAbruptRejectPromise(_bodyString_, _promiseCapability_).
          1. Let _jsonValue_ be Completion(ParseJSON(_bodyString_)).
          1. IfAbruptRejectPromise(_jsonValue_, _promiseCapability_).
          1. Perform Call(_promiseCapability_.[[Resolve]], *undefined*, ¬´ _jsonValue_ ¬ª).
        1. Perform fetch _request_ with processResponseConsumeBody set to _processResponseConsumeBody_.
        1. Return _promiseCapability_.[[Promise]].
      </emu-alg>

      <emu-note>
        <p>For historic reasons, when delivering source maps over HTTP(S), servers may prepend a line starting with the string `)]}'` to the source map.</p>

        <pre><code class="json">)]}'garbage here
{"version": 3, ...}</code></pre>

        <p>is interpreted as</p>

        <pre><code class="json">{"version": 3, ...}</code></pre>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-conventions">
  <h1>Conventions</h1>

  <p>The following conventions should be followed when working with source maps or when generating them.</p>

  <emu-annex id="sec-source-map-naming">
    <h1>Source map naming</h1>

    <p>Commonly, a source map will have the same name as the generated file but with a `.map` extension. For example, for `page.js` a source map named `page.js.map` would be generated.</p>
  </emu-annex>

  <emu-annex id="sec-linking-eval">
    <h1>Linking eval'd code to named generated code</h1>

    <p>There is an existing convention that should be supported for the use of source maps with eval'd code, it has the following form:</p>
    <pre><code class="javascript">//# sourceURL=foo.js</code></pre>

    <p>It is described in Give your eval a name with //@ sourceURL.</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-notes">
  <h1>Notes</h1>

  <emu-annex id="sec-language-neutral-mapping">
    <h1>Language neutral stack mapping</h1>

    <p>Stack tracing mapping without knowledge of the source language is not <emu-not-ref>covered</emu-not-ref> by this document.</p>
  </emu-annex>

  <emu-annex id="sec-multi-level-mapping">
    <h1>Multi-level mapping</h1>

    <p>It is getting more common to have tools generate sources from some DSL (templates) or compile TypeScript ‚Üí JavaScript ‚Üí minified JavaScript, resulting in multiple translations before the final source map is created. This problem can be handled in one of two ways. The easy but lossy way is to ignore the intermediate steps in the process for the purposes of debugging, the source location information from the translation is either ignored (the intermediate translation is considered the ‚ÄúOriginal Source‚Äù) or the source location information is carried through (the intermediate translation hidden). The more complete way is to support multiple levels of mapping: if the Original Source also has a source map reference, the user is given the choice of using that as well.</p>

    <p>However, it is unclear what a "source map reference" looks like in anything other than JavaScript. More specifically, what a source map reference looks like in a language that doesn't support JavaScript-style single-line comments.</p>
  </emu-annex>
</emu-annex>

<emu-annex id="sec-external-definitions">
  <h1>Terms defined in other specifications</h1>

  <p>This section lists all terms and algorithms used by this document defined by external specifications other than ECMA-262.</p>

  <!-- All specifications references here should be also listed in the "References" section at the beginning of the document -->

  <dl>
    <dt>WebAssembly Core Specification &lt;<a href="https://www.w3.org/TR/wasm-core-2/">https://www.w3.org/TR/wasm-core-2/</a>></dt>
    <dd>
      <dfn id="external-webassembly-custom-section" variants="custom sections"><a href="https://www.w3.org/TR/wasm-core-2/#custom-section%E2%91%A0">custom section</a></dfn>,
      <dfn id="external-webassembly-module_decode"><a href="https://www.w3.org/TR/wasm-core-2/#modules%E2%91%A0%E2%91%A4">module_decode</a></dfn>,
      <dfn id="external-webassembly-error"><a href="https://www.w3.org/TR/wasm-core-2/#embed-error">WebAssembly error</a></dfn>,
      <dfn id="external-webassembly-names" variants="WebAssembly name"><a href="https://www.w3.org/TR/wasm-core-2/#names%E2%91%A2">WebAssembly names</a></dfn>
    </dd>
    <dt>WHATWG Encoding &lt;<a href="https://encoding.spec.whatwg.org/">https://encoding.spec.whatwg.org/</a>></dt>
    <dd>
      <dfn id="external-whatwg-encoding-utf-8-decode"><a href="https://encoding.spec.whatwg.org/#utf-8-decode">UTF-8 decode</a></dfn>
    </dd>
    <dt>WHATWG <emu-not-ref>Fetch</emu-not-ref> &lt;<a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>></dt>
    <dd>
      <dfn id="external-whatwg-fetch"><a href="https://fetch.spec.whatwg.org/#concept-fetch">fetch</a></dfn>,
      <dfn id="external-whatwg-fetch-http-newline-byte"><a href="https://fetch.spec.whatwg.org/#http-newline-byte">HTTP newline byte</a></dfn>,
      <dfn id="external-whatwg-fetch-processResponseConsumeBody"><a href="https://fetch.spec.whatwg.org/#process-response-end-of-body">processResponseConsumeBody</a></dfn>,
      <dfn id="external-whatwg-fetch-request"><a href="https://fetch.spec.whatwg.org/#concept-request">request</a></dfn>,
      <dfn id="external-whatwg-fetch-request-url"><a href="https://fetch.spec.whatwg.org/#concept-request-url">request URL</a></dfn>
    </dd>
    <dt>WHATWG Infra &lt;<a href="https://infra.spec.whatwg.org/">https://infra.spec.whatwg.org/</a>></dt>
    <dd>
      <dfn id="external-whatwg-infra-byte-sequence"><a href="https://infra.spec.whatwg.org/#byte-sequence">byte sequence</a></dfn>,
      <dfn id="external-whatwg-infra-byte-sequence-prefix"><a href="https://infra.spec.whatwg.org/#byte-sequence-prefix">byte-sequence-prefix</a></dfn>,
      <dfn id="external-whatwg-infra-byte-sequence-length"><a href="https://infra.spec.whatwg.org/#byte-sequence-length">byte-sequence-length</a></dfn>,
    </dd>
    <dt>WHATWG <emu-not-ref>URL</emu-not-ref> &lt;<a href="https://url.spec.whatwg.org/">https://url.spec.whatwg.org/</a>></dt>
    <dd>
      <dfn id="external-whatwg-url-http-s-scheme"><a href="https://fetch.spec.whatwg.org/#http-scheme">HTTP(S) scheme</a></dfn>,
      <dfn id="external-whatwg-url-scheme"><a href="https://url.spec.whatwg.org/#concept-url-scheme">scheme</a></dfn>,
      <dfn id="external-whatwg-url"><a href="https://url.spec.whatwg.org/#concept-url">URL</a></dfn>,
      <dfn id="external-whatwg-url-parsing"><a href="https://url.spec.whatwg.org/#url-parsing">URL parsing</a></dfn>
    </dd>
  </dl>
</emu-annex>

<emu-annex id="sec-bibliography">
  <h1>Bibliography</h1>
  <ol>
    <li>
      IETF RFC 4648, <i>The Base16, Base32, and Base64 Data Encodings</i>, available at &lt;<a href="https://datatracker.ietf.org/doc/html/rfc4648">https://datatracker.ietf.org/doc/html/rfc4648</a>>
    </li>
    <li>
      ECMA-262, <i>ECMAScript¬Æ Language Specification</i>, available at &lt;<a href="https://tc39.es/ecma262/">https://tc39.es/ecma262/</a>>
    </li>
    <li>
      ECMA-404, <i>The JSON Data Interchange Format</i>, available at &lt;<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-404/">https://www.ecma-international.org/publications-and-standards/standards/ecma-404/</a>>
    </li>
    <li>
      <i>WebAssembly Core Specification</i>, available at &lt;<a href="https://www.w3.org/TR/wasm-core-2/">https://www.w3.org/TR/wasm-core-2/</a>>
    </li>
    <li>
      WHATWG <i>Encoding</i>, available at &lt;<a href="https://encoding.spec.whatwg.org/">https://encoding.spec.whatwg.org/</a>>
    </li>
    <li>
      WHATWG <emu-not-ref><i>Fetch</i></emu-not-ref>, available at &lt;<a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a>>
    </li>
    <li>
      WHATWG <i>Infra</i>, available at &lt;<a href="https://infra.spec.whatwg.org/">https://infra.spec.whatwg.org/</a>>
    </li>
    <li>
      WHATWG <emu-not-ref><i>URL</i></emu-not-ref>, available at &lt;<a href="https://url.spec.whatwg.org/">https://url.spec.whatwg.org/</a>>
    </li>
    <li>
      <dfn id="biblio-give-your-eval-a-name">Give your eval a name with //@ sourceURL</dfn>, Firebug (2009), available at &lt;<a href="https://web.archive.org/web/20120814122523/http://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/">http://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/</a>>
    </li>
    <li>
      <dfn id="biblio-source-map-v2">Source Map Revision 2 Proposal</dfn>, John Lenz (2010), available at &lt;<a href="https://docs.google.com/document/d/1xi12LrcqjqIHTtZzrzZKmQ3lbTv9mKrN076UB-j3UZQ/">https://docs.google.com/document/d/1xi12LrcqjqIHTtZzrzZKmQ3lbTv9mKrN076UB-j3UZQ/</a>>
    </li>
    <li>
      <dfn id="biblio-vlq" variants="variable-length quantity">Variable-length quantity</dfn>, Wikipedia, available at &lt;<a href="https://en.wikipedia.org/wiki/Variable-length_quantity">https://en.wikipedia.org/wiki/Variable-length_quantity</a>>
    </li>
  </ol>
</emu-annex>

<emu-annex id="sec-colophon">
  <h1>Colophon</h1>
  <p>This specification is authored on <a href="https://github.com/tc39/ecma426">GitHub</a> in a plaintext source format called <a href="https://github.com/bterlson/ecmarkup">Ecmarkup</a>. Ecmarkup is an HTML and Markdown dialect that provides a framework and toolset for authoring ECMAScript specifications in plaintext and processing the specification into a full-featured HTML rendering that follows the editorial conventions for this document. Ecmarkup builds on and integrates a number of other formats and technologies including <a href="https://github.com/rbuckton/grammarkdown">Grammarkdown</a> for defining syntax and <a href="https://github.com/domenic/ecmarkdown">Ecmarkdown</a> for authoring algorithm steps. PDF renderings of this specification are produced by printing the HTML rendering to a PDF.</p>
  <p>The first edition of this specification was authored using <a href="https://speced.github.io/bikeshed/">Bikeshed</a>, a different plaintext source format based on HTML and Markdown.</p>
  <p>Pre-standard versions of this document were authored using Google Docs.</p>
</emu-annex>
</emu-clause>
